# 图论

## 树上问题

### 一，树的建立

#### (1)知中后序，求前序遍历

```cpp
//链式结构
typedef struct tree/
{
    int data;
    struct tree* l;
    struct tree* r;
}TREE;

TREE* Build(char* instr,char* poststr,int length)
{
    if (length == 0) return NULL;//如果已经建立完了
    char ch = poststr[length-1];
    int pos = 0;
    while (instr[pos] != ch) pos++;//确定根节点在子树的中序遍历中的位置
    TREE *T = (TREE*)malloc(sizeof(TREE));//分配内存
    T->data = ch;//该节点的值
    T->l = Build(&instr[0],&poststr[0],pos);
    T->r = Build(&instr[pos+1],&poststr[pos],length - pos - 1);
    return T;
}

void pre_order(TREE* p)//先序遍历
{
    printf("%c",p->data);
    if (p->l != NULL) pre_order(p->l);
    if (p->r != NULL) pre_order(p->r);
}

int main()
{
    char instr[30];//中序遍历
    char poststr[30];//后序遍历
    scanf("%s",instr);
    scanf("%s",poststr);
    int n = strlen(instr);//确定结点数
    TREE *head = Build(instr,poststr,n);//头节点指针
    pre_order(head);//先序输出
    return 0;
}
```

#### (2)知前中序，求后序遍历

```cpp
//顺序结构
typedef struct tree
{
    int l,r;
}TREE;
TREE a[300];
int Build(char *instr,char *prestr,int length)
{
    if (length == 0) return 0;//如果已经建立完了
    int ch = prestr[0];
    int pos = 0;
    while (instr[pos] != ch) pos++;//定节点在子树的中序遍历的位置
    a[ch].l = Build(&instr[0],&prestr[1],pos);
    a[ch].r = Build(&instr[pos+1],&prestr[pos+1],length - pos - 1);
    return ch;
}

void post_order(int x)//后序遍历
{
    if (a[x].l) post_order(a[x].l);
    if (a[x].r) post_order(a[x].r);
    printf("%c",x);
}

int main()
{
    char instr[30];
    char prestr[30];
    scanf("%s",instr);//读入中序
    scanf("%s",prestr);//读入前序
    int n = strlen(instr);//确定节点数
    Build(instr,prestr,n);//建立树
    post_order(prestr[0]);//先序遍历
    return 0;
}
```

### 二，树的重心

#### 一般树的重心

```cpp
//通过判断最大子树求重心
void getrt(int x,int fa) // 获取树的重心
{
    big[x] = 1;
    maxn[x] = 0; // 初始化最大子树大小
    for (auto v : e[x])
    {
        int to = v.first;
        if (to == fa || vis[to]) continue; // 注意vis
        getrt(to,x);
        big[x] += big[to];
        maxn[x] = max(big[to],maxn[x]);
    }
    maxn[x] = max(maxn[x],sum - big[x]);
    if (maxn[x] < maxn[rt]) rt = x;
}
```

#### 带权树的重心

```cpp
typedef struct edge//边结构体
{
    int to,next;
}EDGE;
EDGE e[100001<<1];
int head[100001];
int cnt;

long long c[100001];//点权
long long big[100001];//以i为根节点树的大小
long long m[100001];//i的最大子树的大小
long long all;//记录整棵树的大小

int n;//节点数
int p;//重心编号
long long ans;//答案
void add(int x,int y)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void DFS(int x,int fa)//找重心
{
    big[x] = c[x]; // 初始化为点权
    for (int i = head[x]; i; i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
        big[x] += big[e[i].to];
        m[x] = max(m[x],big[e[i].to]);
    }
    m[x] = max(m[x],all-big[x]);//取最大连通块
    if(m[x] <= all/2) p = x;//判断重心
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int x,y;
    cin >> n;
    for (int i = 1; i<=n-1; i++)//建树
    {
        cin >> x >> y;
        add(x,y);
        add(y,x);
    }
    for (int i = 1; i<=n; i++)//计算整棵树的大小
    {
        cin >> c[i];
        all += c[i];
    }
    DFS(1,0);//找重心
    return 0;
}
```

### 三，树的直径

#### 正边权情况

```cpp
typedef struct way
{
    int p,value;
}WAY;
vector <WAY> g[500001];//邻接表存图
long long d[500001];//存答案
int c;//第一次DFS的最远位置，第二次DFS的起始位置及改变后的答案
void DFS(int x,int f)
{
    for (int i = 0,k = g[x].size(); i<k; i++)
    {
        if (g[x][i].p == f) continue;
        d[g[x][i].p] = d[x] + g[x][i].value;
        if (d[g[x][i].p]>d[c]) c = g[x][i].p;//比较并更新最远点
        DFS(g[x][i].p,x);
    }
}

int main()
{
    int n,v,a,b;
    scanf("%d",&n);
    for (int i = 1; i<=n-1; i++)
    {
        scanf("%d%d%d",&a,&b,&v);
        WAY temp = {b,v};
        g[a].push_back(temp);
        temp.p = a,temp.value = v;
        g[b].push_back(temp);
    }
    DFS(1,0);//随便从一个点开始DFS
    d[c] = 0;//变回0
    DFS(c,0);//再次DFS
    printf("%lld\n",d[c]);//输出答案
    return 0;
}
```

#### 含负边权情况

```cpp
typedef struct way//定义边权结构体
{
    int p,value;
}WAY;
vector <WAY> g[500001];//邻接表存图

//d1为寻求直径路上到不同于出发点的另一端点的权值和的最优解，d2为次优解
long long d1[500001],d2[500001];

long long c;//答案
void DFS(int x,int f)
{
    d1[x] = 0,d2[x] = 0;
    for (int i = 0,k = g[x].size(); i<k; i++)
    {
        if (g[x][i].p == f) continue;
        DFS(g[x][i].p,x);
        int t = d1[g[x][i].p] + g[x][i].value;
        if (t > d1[x])//大于当前点最优解，更新最优与次优
        {
            d2[x] = d1[x];
            d1[x] = t;
        }
        else if (t > d2[x])//仅大于次优解，更新
        {
            d2[x] = t;
        }
    }
    c = max(c,d1[x] + d2[x]);//套公式，取最大值
}

int main()
{
    int n,v,a,b;
    scanf("%d",&n);
    for (int i = 1; i<=n-1; i++)
    {
        scanf("%d%d%d",&a,&b,&v);
        WAY temp = {b,v};
        g[a].push_back(temp);
        temp.p = a,temp.value = v;
        g[b].push_back(temp);
    }
    DFS(1,0);//无根树，从任意一点当作根节点出发
    printf("%lld\n",c);
    return 0;
}
```

### 四，最近公共祖先(LCA)

#### 倍增算法

```cpp
//可以预处理logn，但是本文无
typedef struct edge
{
    int to,next;
}EDGE;
EDGE e[500001<<1];
int head[500001];

int number;//双边总数
int depth[500001];//每个点的深度
int f[500001][30];//2^i祖先

inline int read()//快读
{
    int s = 0;
    char ch = getchar();
    while (ch<'0'||ch>'9')
    {
        ch = getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

void add(int x,int y)
{
    e[++number].to = y;
    e[number].next = head[x];
    head[x] = number;
}

void DFS(int x,int fa)//预处理LCA
{
    depth[x] = depth[fa] + 1;
    f[x][0] = fa;
    for (int i = 1; (1<<i)<=depth[x]; i++)
    {
        f[x][i] = f[f[x][i-1]][i-1];
    }
    for (int i = head[x]; i; i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
    }
}

int Solve(int a,int b)//倍增LCA
{
    if (a == b) return a;
    if (depth[a] < depth[b]) swap(a,b);
    while (depth[a] > depth[b])
    {
        a = f[a][(int)(log(depth[a]-depth[b])/log(2))];
    }
    if (a == b) return a;
    for (int i = (int)(log(depth[a])/log(2)); i>=0; i--)
    {
        {
            if(f[a][i] != f[b][i])
            {
                a = f[a][i];
                b = f[b][i];
            }
        }
    }
    return f[a][0];
}

int main()
{
    int n,m,s,a,b;
    n = read(),m = read(),s = read();
    for (int i = 1; i<=n-1; i++)
    {
        a = read();
        b = read();
        add(a,b);
        add(b,a);
    }
    depth[0] = -1;//初始化深度为-1
    DFS(s,0);//从根节点开始搜索
    for (int i = 1; i<=m; i++)
    {
        printf("%d\n",Solve(read(),read()));
    }
    return 0;
}
```

#### DFS序求LCA

```cpp
//预处理o(nlogn)，单次查询o(1)
constexpr int N = 5e5 + 5;
int n, m, rt;
int dfn[N], mi[19][N], dfncnt;
vector<int> e[N];

int get(int x, int y) {return dfn[x] < dfn[y] ? x : y;}

void dfs(int x, int f) 
{
    dfn[x] = ++dfncnt;
    mi[0][dfncnt] = f;
    for (auto to : e[x])
    {
        if (to == f) continue;
        dfs(to,x);
    }
}

int lca(int u, int v) 
{
    if(u == v) return u;
    if((u = dfn[u]) > (v = dfn[v])) swap(u, v);
    int d = __lg(v - u++);
    return get(mi[d][u], mi[d][v - (1 << d) + 1]);
}

int main() 
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin >> n >> m >> rt;
    for(int i = 1, x, y; i <= n-1; i++) 
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    dfs(rt,0);
    for(int i = 1; i <= __lg(n); i++) // __lg(n)计算log2
    {
        for(int j = 1; j + (1 << i) - 1 <= n; j++)
        {
            mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
        }
    }
    for(int i = 1, x, y; i <= m; i++)
    {
        cin >> x >> y;
        cout << lca(x,y) << "\n";
    }
    return 0;
}
```

#### Tarjan离线o(n)

```cpp
typedef struct edge
{
    int to,next,v;
}EDGE;

EDGE e[500001<<1];//边数组
int head[500001];//i编号边的起点
int cnt;//边的数量
EDGE ask[500001<<1];//询问数组
int hask[500001];//i编号询问的其中一个数
int cask;//询问数组有用的数量
int f[500001];//并查集根节点数组
bool visit[500001];//标记数组
int ans[500001];//存储答案的数组，ans[i]对应第i次询问的答案

inline int read()//快读，不用说了
{
    int s = 0;
    char ch = getchar();
    while (ch < '0'||ch > '9') ch = getchar();
    while (ch <= '9'&&ch >= '0')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

int Find(int x)//并查集查找加路径压缩
{
    if (x == f[x]) return x;
    else return f[x] = Find(f[x]);
}

void add(int x,int y)//加边函数
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void adda(int x,int y,int a)//记录询问函数
{
    ask[++cask].to = y;
    ask[cask].v = a;//该两数边的询问是第a个
    ask[cask].next = hask[x];
    hask[x] = cask;
}

void DFS(int x,int fa)//一次DFS结合Tarjan求LCA
{
    for (int i = head[x];i;i = e[i].next)//遍历子树
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
    }
    for (int i = hask[x];i;i = ask[i].next)//遍历于该点有关的问题询问
    {
        if(ask[i].to == x)//Hack数据，如果询问是自己
        {
            ans[ask[i].v] = x;//不管visit直接记录答案，否则不会再次来到自己这个位置
            continue;//继续
        }
        if(visit[ask[i].to])//如果于该节点连接的问题的点已经到达过
        {
            ans[ask[i].v] = Find(ask[i].to);//记录答案
        }
    }
    visit[x] = true;//标记当前点
    f[x] = fa;//改变父节点
}

int main()
{
    int n = read();//读入节点个数
    int q = read();//读入询问次数
    int s = read();//读入根节点编号
    for (int i = 1;i<=n;i++) f[i] = i;//!!!!一定要初始化并查集
    for (int i = 1;i<=n-1;i++)//建树
    {
        int a = read();
        int b = read();
        add(a,b);
        add(b,a);
    }
    for (int i = 1;i<=q;i++)//建立询问的边
    {
        int a = read();
        int b = read();
        adda(a,b,i);
        adda(b,a,i);
    }
    DFS(s,0);//一次DFS加Tarjan，找到答案
    for (int i = 1;i<=q;i++)//按顺序输出对应询问的答案
    {
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

### 五，树上差分

#### 点差分

```cpp
vector<int> e[50005];
int cha[50005]; // 差分数组
int f[50005][35];
int depth[50005];
int logn[50005];
int ans;

void prework()
{
    logn[1] = 0;
    for (int i = 2;i<=50000;i++) logn[i] = logn[i/2] + 1;
}

void DFS(int x,int fa,int d)
{
    depth[x] = d;
    f[x][0] = fa;
    for (int i = 1;(1<<i)<=depth[x];i++) f[x][i] = f[f[x][i-1]][i-1];
    for (auto v:e[x])
    {
        if(v == fa) continue;
        DFS(v,x,d+1);
    }
}

void Count(int x,int fa)
{
    for (auto v:e[x])
    {
        if(v == fa) continue;
        Count(v,x);
        cha[x] += cha[v];
    }
    ans = max(ans,cha[x]);
}

int LCA(int a,int b)
{
    if(depth[a] < depth[b]) swap(a,b);
    while(depth[a] > depth[b]) a = f[a][logn[depth[a]-depth[b]]];
    if(a == b) return a;
    for (int i = logn[depth[a]];i>=0;i--)
    {
        if(f[a][i] != f[b][i])
        {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();
    int n,k,x,y;
    cin >> n >> k;
    for (int i = 1;i<=n-1;i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    DFS(1,0,0);
    for (int i = 1; i <= k ;i++)
    {
        cin >> x >> y;
        int lca = LCA(x,y);
        //核心差分
        cha[x]++;
        cha[y]++;
        cha[lca]--;
        cha[f[lca][0]]--;
    }
    Count(1,0);
    cout<<ans<<"\n";
    return 0;
}
```

#### 边差分

```cpp
//原理:LCA + 树上边差分
typedef struct edge
{
    int to,next,num;//num为边的号码
}EDGE;
EDGE e[100001<<1];
int head[100001];
int cnt;
int d[100001];//差分数组兼具前缀和数组
int f[100001][30];
int depth[100001];
int logn[100001];
int ans[100001];

void prework()//预处理对数数组
{
    logn[1] = 0;
    for (int i = 2;i<=100000;i++) logn[i] = logn[i/2] + 1;
}

void add(int x,int y,int c)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    e[cnt].num = c;
    head[x] = cnt;
}

void DFS(int x,int fa,int d)//预处理LCA
{
    depth[x] = d;
    f[x][0] = fa;
    for (int i = 1;(1<<i)<=depth[x];i++) f[x][i] = f[f[x][i-1]][i-1];
    for (int i = head[x];i;i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x,d+1);
    }
}

void Count(int x,int fa,int pos)//差分求和
{
    for (int i = head[x];i;i = e[i].next)
    {
        if(e[i].to == fa) continue;
        Count(e[i].to,x,e[i].num);
        d[x] += d[e[i].to];
    }
    ans[pos] = d[x];//记录对应边的答案
}

int LCA(int a,int b)
{
    if(a == b) return a;
    if(depth[a] < depth[b]) swap(a,b);
    while(depth[a] > depth[b]) a = f[a][logn[depth[a]-depth[b]]];
    if(a == b) return a;
    for (int i = logn[depth[a]];i>=0;i--)
    {
        if(f[a][i] != f[b][i])
        {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();
    int n,k,x,y;
    cin>>n;
    for (int i = 1;i<=n-1;i++)
    {
        cin>>x>>y;
        add(x,y,i);
        add(y,x,i);
    }
    DFS(1,0,0);
    cin>>k;
    for (int i = 1;i<=k;i++)
    {
        cin>>x>>y;
        int lca = LCA(x,y);
        d[x]++;
        d[y]++;
        d[lca] -= 2;
    }
    Count(1,0,0);
    for (int i = 1;i<=n-1;i++) cout<<ans[i]<<" ";//依次输出答案
    return 0;
}
```

### 六，树上启发式合并(dsu on tree)

```cpp
typedef struct edge
{
    int to,next;
}EDGE;

EDGE e[100001<<1];
int head[100001];
int cnt;

int color[100001];//每个节点的颜色
int colornumber;//当前颜色种类数
int all[100001];//每种颜色出现的次数

int big[100001];//以i为根节点的树的大小
int son[100001];//以i为根的树的重儿子
int ans[100001];//答案数组
int l[100001];//存储i节点的DFS序
int r[100001];//存储i节点所能遍历到的最大DFS序
int Node[100001];//记录DFS序为i的节点
int pos;//记录DFS序

inline int read()//快读
{
    int s = 0;
    char ch = getchar();
    while(ch < '0'||ch > '9') ch = getchar();
    while(ch >= '0'&&ch <= '9')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

void add(int x,int y)//建边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void addcolor(int x)//添加节点x的颜色贡献
{
    if(all[color[x]] == 0) colornumber++;
    all[color[x]]++;
}

void delcolor(int x)//删除节点x的颜色贡献
{
    all[color[x]]--;
    if(all[color[x]] == 0) colornumber--;
}

int getans()//获取当前颜色数目
{
    return colornumber;
}

void DFS1(int x,int fa)//预处理树,时间复杂度:o(n)
{
    big[x] = 1;//初始化树的大小
    l[x] = ++pos;//更新DFS序,并记录节点x的DFS序
    Node[pos] = x;//记录当前DFS序代表的节点
    for (int i = head[x];i;i = e[i].next)//遍历子树
    {
        if(e[i].to == fa) continue;
        DFS1(e[i].to,x);
        big[x] += big[e[i].to];//更新大小
        if(son[x] == 0||big[e[i].to] > big[son[x]]) son[x] = e[i].to;//更新节点x的重儿子
    }
    r[x] = pos;//记录当前节点所能到达的最大DFS序
}

void DFS2(int x,int fa,bool keep)//keep含义为此次DFS是否要保留(该函数用先到底理解)
{
    for (int i = head[x];i;i = e[i].next)//计算轻儿子的答案
    {
        if(e[i].to == fa||e[i].to == son[x]) continue;
        DFS2(e[i].to,x,false);
    }
    if(son[x])//计算重儿子的答案并保留数据(用于继承)
    {
        DFS2(son[x],x,true);//keep改为true
    }
    for (int i = head[x];i;i = e[i].next)//再次计算轻儿子
    {
        if(e[i].to == fa||e[i].to == son[x]) continue;
        for (int j = l[e[i].to];j<=r[e[i].to];j++)//子树节点的DFS序构成连续区间,直接遍历(省了很多递归函数的编写及简化理解)
        {
            addcolor(Node[j]);//添加颜色贡献
        }

    }
    addcolor(x);//加上自己
    ans[x] = getans();//获取答案,记录
    if(!keep)//如果不保留
    {
        for (int i = l[x];i<=r[x];i++)//删掉整棵以x为节点的树的贡献(因为keep == false,说明此节点是某节点的轻儿子的第一次遍历,可删)
        {
            delcolor(Node[i]);//删除贡献
        }
    }
}

int main()
{
    int n = read();//读入节点个数
    for (int i = 1;i<=n-1;i++)//建树
    {
        int a = read();
        int b = read();
        add(a,b);
        add(b,a);
    }
    for (int i = 1;i<=n;i++) color[i] = read();//读入每个节点颜色
    DFS1(1,0);//预处理树
    DFS2(1,0,false);//计算答案!!!核心函数(难理解)
    int q = read();//读入询问数
    for (int i = 1;i<=q;i++)//依次处理每次询问
    {
        int ask = read();
        printf("%d\n",ans[ask]);//o(1)输出答案
    }
    return 0;
}
```

### 七，点分治

```cpp
#define MAXN 100010
#define INF 10000001
int n,m;
int ask[1005]; // 记录询问
vector<pair<int,int>> e[MAXN]; // 边数组
int big[MAXN],maxn[MAXN],sum,rt; // 重心相关
bool judge[INF],ans[INF],vis[MAXN]; // 分治及记录相关
int dis[MAXN]; // 到根节点的距离
int rem[MAXN]; // 记录产生的距离
int que[MAXN]; // 记录此次计算过后要清空的距离

void getrt(int x,int fa) // 获取树的重心
{
    big[x] = 1;
    maxn[x] = 0; // 初始化
    for (auto v : e[x])
    {
        int to = v.first;
        if (to == fa || vis[to]) continue; // 注意vis
        getrt(to,x);
        big[x] += big[to];
        maxn[x] = max(big[to],maxn[x]);
    }
    maxn[x] = max(maxn[x],sum - big[x]);
    if (maxn[x] < maxn[rt]) rt = x;
}

void getdis(int x,int fa) // 获取到根节点的距离
{
    rem[++rem[0]] = dis[x]; // 记录记录
    for (auto v : e[x])
    {
        int to = v.first;
        int w = v.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[x] + w;
        getdis(to,x);
    }
}

void calc(int x) // 计算路径的核心函数
{
    int p = 0; // 初始化
    for (auto v : e[x])
    {
        int to = v.first;
        int w = v.second;
        if (vis[to]) continue;
        rem[0] = 0; // rem[0]用于记录当前节点的子树产生了多少个距离
        dis[to] = w;
        getdis(to,x);// 处理每个子树到当前节点(当前为根)的dis

        for (int i = 1; i <= rem[0]; i++) // 遍历当前节点为根产生的距离
        {
            for (int j = 1; j <= m; j++) // 遍历问题
            {
                if (ask[j] >= rem[i]) ans[j] |= judge[ask[j]-rem[i]]; // dp
            }
        }

        // 标记当前的距离
        for (int i = 1; i <= rem[0]; i++)
        {
            judge[rem[i]] = true;
            que[++p] = rem[i];
        }
    }
    // 处理完这个子树就清空judge
    for (int i = 1; i <= p; i++) judge[que[i]] = false;
}

void Solve(int x)
{
    vis[x] = judge[0] = true; // 到当前节点为0就是自己，且标记自己已经被当作子树处理过了
    calc(x); // 处理以x为根的子树
    for (auto v : e[x])
    {
        int to = v.first;
        if (vis[to]) continue;
        rt = 0; // 重新定义根
        maxn[rt] = INF;
        sum = big[to]; // 定义子树的大小
        getrt(to,0); // 找到子树的重心
        Solve(rt);
    }
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int x,y,w;
    cin >> n >> m;
    for (int i = 1; i <= n-1; i++)
    {
        cin >> x >> y >> w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    for (int i = 1; i <= m; i++) cin >> ask[i];
    maxn[rt] = sum = n; // 第一次先找一整棵树的重心，保证计算的时间复杂度
    getrt(1,0);
    Solve(rt);
    for (int i = 1; i <= m; i++)
    {
        if (ans[i]) cout << "AYE" << "\n";
        else cout << "NAY" << "\n";
    }
    return 0;
}
```

### 八，生成树

#### 最小生成树

##### Kruskal算法

```cpp
//特定的数据结构维护:并查集
//时间复杂度:o(mlogm+(a)n),主要来自于排序及并查集查询,m为边数,n为点数
typedef struct edge//直接存边
{
    int b,e,v;
}EDGE;
EDGE e[200001];
int f[200001];//并查集数组

int Find(int x)//并查集查找
{
    if (x == f[x]) return x;
    else return f[x] = Find(f[x]);
}

bool cmp(EDGE x,EDGE y)//边结构体按边权排序
{
    return x.v < y.v;
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i;//初始化并查集
    for (int i = 1; i <= m; i++) cin >> e[i].b >> e[i].e >> e[i].v;
    sort(e+1,e+m+1,cmp);//排序
    int ans = 0;//初始化答案
    int finish = 0;//初始化完成的边数
    for (int i = 1;i<=m;i++)//枚举边
    {
        if (finish == n-1) break;//已经建好树了,退出
        int f1 = Find(e[i].b);//查找祖先
        int f2 = Find(e[i].e);//查找祖先
        if (f1 == f2) continue;//如果成环,之前有更小的边,跳过
        finish++;//边数加1
        ans += e[i].v;//答案累加
        f[f1] = f2;//连通区域合并合并
    }
    if (finish == n-1) cout << ans << "\n";//如果有MST,输出最小权值和
    else cout << "orz" << "\n";//否则输出无
    return 0;
}
```

##### Prim算法(暴力)，适用于稠密图

```cpp
//时间复杂度:o(n^2 + m),n为点,m为边
typedef struct edge//链式前向星存边
{
    int to,next,value;
}EDGE;

//边相关数组
EDGE e[200001<<1];
int head[5001];
int cnt;

//Prim相关数组
int dis[5001];//记录当前节点到连通区域的最近距离
bool vis[5001];//标记节点是否已经在连通块里
int ans,finish,now = 1;//ans为最小生成树权值和,finish为已完成的边(其实对于Prim算法,用点计数更合理),now为当前加入的点

//初始变量,n为点数,m为边数
int n,m;
void add(int x,int y,int v)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    e[cnt].value = v;
    head[x] = cnt;
}
void Prim()//朴素Prim算法
{
    memset(dis,127,sizeof(dis));//初始化dis数组,如果一直为无穷大,则认为图不连通,无解
    for (int i = head[1]; i; i = e[i].next)//以1为根开始计算
    {
        dis[e[i].to] = min(dis[e[i].to],e[i].value);//取最小值
    }
    while(++finish < n)//树最多n-1条边
    {
        int minn = 99999999;//初始化到当前连通块的最小距离(可用于判断无解)
        vis[now] = true;//当前节点加入了连通块
        for (int i = 1; i<=n; i++)//遍历所有点,找到距离当前连通块最近的点
        {
            if (vis[i]) continue;//如果已经在连通块中,不必考虑,跳过
            if(dis[i] < minn)
            {
                minn = dis[i];
                now = i;
            }
        }
        ans += minn;//累加权值(!!!如果minn还是9999999,则可退出循环,因为无解了)
        for (int i = head[now]; i ;i = e[i].next)//由新连接的点去更新与之相连的点到连通块的最近距离
        {
            if(vis[e[i].to]) continue;
            if(dis[e[i].to] > e[i].value) dis[e[i].to] = e[i].value;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int x,y,v;
    cin >> n >> m;//输入点与边个数
    for (int i = 1;i<=m;i++)//建图
    {
        cin >> x >> y >> v;
        add(x,y,v);
        add(y,x,v);
    }
    Prim();
    cout<<ans<<"\n";//输出
    return 0;
}
```

##### Prim算法(堆优化)

```cpp
//时间复杂度:o(nlogm + m)
typedef struct edge//链式前向星存边
{
    int to,next,value;
}EDGE;
//边相关数组
EDGE e[200001<<1];
int head[5001];
int cnt;
//Prim相关数组
int dis[5001];//记录每个节点到已生成连通块的最小距离
int ans,finish;//记录答案及已加入的点的个数
bool vis[5001];//标记点是否已经在当前连通块中
//初始化变量,节点及边数量
int n,m;
//堆自定义相关
struct S
{
    int number,d;//记录当前点编号及到连通块的距离
};
bool operator<(const S&x,const S&y)//按到连通块的距离排序
{
    return x.d>y.d;
}
priority_queue<S> heap;//自定义堆

void add(int x,int y,int v)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    e[cnt].value = v;
    head[x] = cnt;
}
void Prim()//核心Prim
{
    memset(dis,127,sizeof(dis));//初始化dis为无穷大
    S temp = {1,0};
    heap.push(temp);//以1为起点开始Prim
    while (!heap.empty())//如果不空
    {
        if (finish >= n) break;//已经完成n个节点的连接,退出循环
        int u = heap.top().number;//获取堆顶的节点编号
        int d = heap.top().d;//获取最近距离
        heap.pop();//弹出
        if(vis[u]) continue;//如果已经连接,跳过
        vis[u] = true;//标记
        ans += d;//累加答案
        finish++;//已连接节点数加1
        for (int i = head[u]; i; i = e[i].next)//以当前节点去更新其他节点到当前连通块的距离
        {
            if (vis[e[i].to]) continue;//如果已经在连通块,跳过
            if (dis[e[i].to] > e[i].value)//如果更优(即比之前到连通块更近)
            {
                S save = {e[i].to,e[i].value};//存储相关数据
                heap.push(save);//入堆
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int x,y,v;
    cin >> n >> m;//输入节点个数及边的个数
    for (int i = 1; i<=m; i++)//建图
    {
        cin >> x >> y >> v;
        add(x,y,v);
        add(y,x,v);
    }
    Prim();
    if(finish == n) cout << ans << "\n";//有生成树,输出答案
    else cout << "orz" << "\n";//否则没有
    return 0;
}
```

##### 最小生成树唯一性判断(基于Kruskal算法)

```cpp
//背景:看似简单的思路,实际上细节多!!!代码坑多
//时间复杂度:o(mlogm + 2*m*a(n))
#include <bits/stdc++.h>
using namespace std;
typedef struct edge//Kruskal边结构体
{
    int a,b,value;
}EDGE;
EDGE e[100005];//边集
int f[1005];//并查集数组
bool cmp(EDGE x,EDGE y)//自定义比较
{
    return x.value<y.value;
}
int Find(int x)//并查集查找
{
    if(x == f[x]) return x;
    else return f[x] = Find(f[x]);
}
void Solve()//解决问题函数
{
    int n,m;
    cin>>n>>m;//输入节点数及边数
    for (int i = 1; i<=n; i++) f[i] = i;//初始化并查集
    for (int i = 1; i<=m; i++) cin >> e[i].a >> e[i].b >> e[i].value;//输入边数据
    sort(e+1,e+m+1,cmp);//排序
    //保险:让溢出的部分已知
    e[m+1].value = 0;
    e[m+1].a = 0;
    e[m+1].b = 0;
    //核心变量
    int finish = 0;//完成的边(因为题目求MST是否唯一,默认了有,所有该变量在我有保险的条件下无用,或者是说题目专门卡了e[m+1]这一点,可以i>m,break)
    int ans = 0;//最小权值和
    int sum1 = 0;//每个阶段相同的可放的边条数
    int sum2 = 0;//每个阶段实际放的条数
    int tail = 0;//尾指针,用于确定阶段的
    bool flag = false;//判断是否唯一
    for (int i = 1; i<=m+1; i++)//注意这里要是m+1,否则可能最后一次无法判断
    {
        if(i>tail)//该更换阶段了
        {
            if(sum1 != sum2)//如果实际用的与可用的数量不同
            {
                flag = true;//标记不唯一
                break;//退出循环
            }
            sum1 = 0;//重置阶段计数
            sum2 = 0;
            for (int j = i; j<=m+1; j++)//m+1还是要开保险安全
            {
                if (e[j].value != e[i].value)
                {
                    tail = j-1;//更新尾指针
                    break;//退出
                }
                if (Find(e[j].a) != Find(e[j].b)) sum1++;//如果可加,可加边数加1
            }
        }
        //注意这里不能else，因为更换阶段时的那一点也要用于判断的
        if(finish == n-1) continue;//有保险的情况下可有可无,无的话也可以无,加上i>m break  !!!注意不能break,否则判断不全
        int x = Find(e[i].a);
        int y = Find(e[i].b);
        if (x == y) continue;//判断是否可以连接
        f[x] = y;//合并
        finish++;//边加1
        sum2++;//实际阶段边数加1
        ans += e[i].value;//答案累加
    }
    if(flag) cout << "Not Unique!" << "\n";//不唯一输出
    else cout << ans << "\n";//输出答案
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int t;
    cin >> t;//输入测试组数
    while(t--)
    {
        Solve();
    }
    return 0;
}
```

### 九，Kruskal重构树

```cpp
//思路：题目的大意为两点路径上的边权的最小值的最大值，想到Kruskal重构最大树
//原理：Kruskal重构树 + 最大生成树
#include <bits/stdc++.h>
#define ll long long
using namespace std;
typedef struct edge // Kruskal生成树边结构体
{
    int a,b;
    ll value;
}EDGE;
EDGE e[100005];
vector<int> et[10005<<1]; // 重构树
int f[10005<<1];
ll val[10005<<1]; // 记录点权，仅有Kruskal新节点才有
int cnt; // 节点编号
int dp[10005<<1][30]; // 倍增父节点
int depth[10005<<1]; // 深度数组
int logn[10005<<1]; // 预处理对数
bool cmp(EDGE x,EDGE y) // 最大生成树排序
{
    return x.value > y.value;
}
void prework() // 预处理工作
{
    logn[1] = 0;
    for (int i = 2; i <= 20005; i++) logn[i] = logn[i/2] + 1;
}
int Find(int x) // 并查集查找
{
    if (x == f[x]) return x;
    else return f[x] = Find(f[x]);
}
void DFS(int x,int fa,int d) // DFS预处理
{
    depth[x] = d;
    dp[x][0] = fa;
    for (int i = 1; (1 << i) <= depth[x]; i++) dp[x][i] = dp[dp[x][i-1]][i-1];
    for (auto to : et[x])
    {
        if (to == fa) continue;
        DFS(to,x,d+1);
    }
}
int LCA(int a,int b) // 倍增求LCA
{
    if (depth[a] < depth[b]) swap(a,b);
    while (depth[a] > depth[b]) a = dp[a][logn[depth[a] - depth[b]]];
    if (a == b) return a;
    for (int i = logn[depth[a]]; i >= 0; i--)
    {
        if (dp[a][i] != dp[b][i])
        {
            a = dp[a][i];
            b = dp[b][i];
        }
    }
    return dp[a][0];
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();
    int n,m,q,x,y;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i; // 并查集初始化
    for (int i = 1; i <= m; i++)
    {
        cin >> e[i].a >> e[i].b >> e[i].value;
    }
    sort(e+1,e+m+1,cmp);
    cnt = n; // 初始化节点编号
    for (int i = 1; i <= m; i++) // 最大生成树
    {
        x = Find(e[i].a);
        y = Find(e[i].b);
        if (x == y) continue;
        cnt++; // 编号累加
        f[x] = f[y] = f[cnt] = cnt; // 注意新节点也要并查集初始化 
        val[cnt] = e[i].value; // 记录点权
        et[cnt].push_back(x); // 注意是x，而不是e[i].a
        et[cnt].push_back(y); // 连y
    }
    for (int i = 1; i <= cnt; i++) // 预处理
    {
        if (Find(i) == i) DFS(i,0,0); // 对于每个根节点
    }
    cin >> q;
    while (q--) // 回答询问
    {
        cin >> x >> y;
        if (Find(x) != Find(y)) // 如果不连通
        {
            cout << -1 << "\n";
            continue;
        }
        int lca = LCA(x,y);
        //cout << x << " "<< y << " " << lca << "\n";
        cout << val[lca] << "\n";
    }
    return 0;
}
```

## 最短路

### 一，全源最短路

#### floyd算法

```cpp
for (k = 1; k <= n; k++) 
{
    for (x = 1; x <= n; x++) 
    {
        for (y = 1; y <= n; y++) 
        {
            f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
        }
    }
}
```

### 二，单源最短路

#### Dijkstra算法

```cpp
//适用条件:仅适用于正边权
//数据结构:单调队列
//时间复杂度:o(mlogm)
typedef struct edge//链式前向星存边
{
    int to;
    long long value;
}EDGE;
typedef struct node//单调队列数据类型
{
    int u;//编号
    long long dis;//当前的最短路
}NODE;
struct cmp//自定义优先队列排序,维护小根堆
{
    bool operator()(NODE x,NODE y)
    {
        return x.dis > y.dis;
    }
};
vector<EDGE> e[100001];//邻接表存图
long long dis[100001];//最短路
bool vis[100001];//标记数组
priority_queue<NODE,vector<NODE>,cmp> heap;//优先队列
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,s,x,y;
    long long v;
    cin >> n >> m >> s;
    memset(dis,0x3f,sizeof(dis));//初始化为无穷
    dis[s] = 0;//初始化为0
    for (int i = 1;i<=m;i++)//建图
    {
        cin >> x >> y >> v;
        e[x].push_back({y,v});
    }
    heap.push({s,dis[s]});//起点入队
    while(!heap.empty())//Dijkstra算法
    {
        x = heap.top().u;//获取堆顶,即目前未算出最短路的集合中的最小值对应的点
        heap.pop();//弹出
        if(vis[x] == true) continue;//如果之前已经加入了最短路集合中,跳过它(因为不可能更优)
        vis[x] = true;//标记
        for (auto t:e[x])//松弛与该点有关的边
        {
            if(dis[t.to] > dis[x] + t.value)//如果更优
            {
                dis[t.to] = dis[x] + t.value;//更新
                heap.push({t.to,dis[t.to]});//入队
            }
        }
    }
    for (int i = 1;i<=n;i++) cout << dis[i] << " ";//输出
    return 0;
}
```

#### SPFA(可判断负环)

```cpp
typedef struct edge//链式前向星结构
{
    int to,value;
}EDGE;
vector<EDGE> e[500001];//邻接表存图
int cnt[10001];//用于判断负环的
int dis[10001];//单源最短路数组
bool vis[10001];//入队数组,防止重复入队
const int INF = 0x3f3f3f3f;//无穷大
const int no = ((long long)(1)<<31) - 1;//无解值
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,s,x,y,v;
    cin >> n >> m >> s;
    memset(dis,0x3f,sizeof(dis));//初始化
    dis[s] = 0;//初始化
    for (int i = 1; i<=m; i++)//建图
    {
        cin >> x >> y >> v;
        e[x].push_back({y,v});
    }
    vis[s] = true;//标记入队了
    queue<int> que;
    que.push(s);
    while (!que.empty())//SPFA算法
    {
        int now = que.front();
        que.pop();
        vis[now] = false;//出队后取消标记
        for (auto d:e[now])//遍历边
        {
            x = d.to,
            y = d.value;
            if(dis[x] > dis[now] + y)//更新最短路
            {
                dis[x] = dis[now] + y;
                cnt[x] = cnt[now] + 1;
                if(cnt[x] >= n)//如果超过了n-1条边,说明有负环
                {
                    cout<<"Have negative cycle!"<<"\n";//输出
                    return 0;//结束程序
                }
                if(!vis[x])//如果之前没有入队
                {
                    que.push(x);//在这一次入
                    vis[x] = true;//标记
                }
            }
        }
    }
    for (int i = 1; i<=n; i++)//输出
    {
        if(dis[i] == INF) cout << no << " ";
        else cout << dis[i] << " ";
    }
    return 0;
}
```

## 拓扑排序

### 一，Kahn算法(模板)

```cpp
queue<int> que;//初始化队列
for (int i = 1;i<=n;i++)//遍历顶点
{
    if(in[i] == 0) que.push(i);//入度为0的入队
}
vector <int> ans;//拓扑排序结果序列
while(!que.empty())
{
    int v = que.front();
    que.pop();
    ans.push_back(v);
    for (int i = head[v]; i; i = e[i].next)
    {
        in[e[i].to]--;
        if (in[e[i].to] == 0) que.push(e[i].to);
    }
}
```

### 二，拓扑排序唯一性判断

```cpp
queue<pair<char,int>> que;//集合中记录每个字母及其入度为0时的层数
vector<char> ans;//存储答案
int check = 0;//记录最大层数的
for (auto v : s)//找入度为0的点
{
    if (intemp[v] == 0) que.push({v,1});//入队且层数为1
}
while (!que.empty())//kahn算法,BFS
{
    char ch = que.front().first;//取字母
    int t = que.front().second;//取层数
    que.pop();//弹出!!!!
    ans.push_back(ch);//记录答案
    for (int i = head[ch]; i; i = e[i].next)//遍历它的边
    {
        intemp[e[i].to]--;//入度减1
        if(intemp[e[i].to] == 0)//当入度为0
        {
            que.push({e[i].to,t+1});//由当前层数加1
            check = max(check,t+1);//更新最大层数
        }
    }
}
//有稳定拓扑排序说明拓扑排序的层数是n,即最后判断无环的情况下层数是否为n
```

## 环问题

### 一，DFS环判断并记录环路(无向图)

```cpp
//原理:我的DFS判断简单图是否有环(简单图没有自环),可能会有错误!
//更新:其实还是并查集判断环好,然后再DFS找环方便(在线做法输入,处理并查集的时候知道了环上的两点,可用简洁办法)
const int maxn = 100005;
int parent[maxn+1];
vector<int> cycle;
bool vis[maxn+1];//标记数组
vector<int> e[maxn+1];//邻接表存图
bool flag = false;//判断依据
void DFS(int x,int fa)
{
    if(flag) return;//如果已经找到了,一定要返回,否则可能会有重复入环数组
    parent[x] = fa;
    vis[x] = true;//标记
    for (int i = 0,big = e[x].size(); i<big; i++)
    {
        if(e[x][i] == fa) continue;//特判父亲,父亲的回路不算的
        if(vis[e[x][i]])//如果有指向之前已经标记节点的回路(一定违反了树的性质,而不是树就一定有环),有环,返回
        {
            int temp = e[x][i];//获取临界交界处
            int tx = x;//存储x,防止操作改变了x
            cycle.push_back(x);
            cycle.push_back(temp);
            while(parent[tx]&&parent[tx] != temp)//寻找到断开为止,可能是没有了或者到了原先成环的交界处
            {
                tx = parent[tx];
                cycle.push_back(tx);
            }
            flag = true;
        }
        //如果上面的找到了,那么下面的一旦进入就会直接退出
        DFS(e[x][i],x);//否则继续DFS(注意这里不要让x变,虽然不影响,但是逻辑错误)
        if (flag) return;//(因为上一次的返回是从这里出来的,所以要在这里返回,不要写在了上面)找到环并记录后,终止一切行为,防止重复搜索
    }
}
void Solve()
{
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1;i<=m;i++)//建立无向图
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    for (int i = 1;i<=n;i++)
    {
        if(flag == false&&vis[i] == false)//仅对还没标记的点进行DFS判断且此时还没有环
        {
            //因为图不一定连通,所以可能不同连通块中可能有环
            DFS(i,0);//获取标记
        }
    }
    if(flag)
    {
        cout << "The Graph has cycle!" << "\n";//有环
        for (auto v : cycle) cout << v << " ";
        cout << "\n";
    }
    else cout << "The Graph has no cycle!" << "\n";//无环
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    while (t--)
    {
        Solve();
    }
    return 0;
}
```

### 二，最小环(Floyd算法)

```cpp
for (int k = 1; k<=n; k++)
{
    for (int i = 1; i<=n; i++)
    {
        for (int j = 1; j<=n; j++)
        {
            //在更新最短路之前求最小环
            if(i != k&&j != k&&i != j) ans = min(ans,f[i][j] + e[i][k] + e[j][k]);//如果三个点不相等才能是环
            f[i][j] = min(f[i][j],f[i][k] + f[k][j]);//可以更新了,因为这一次k已经用过了(i,j),不可能再用了
            }
    }
}
```

### 三，负环(SPFA算法)

```cpp
typedef struct edge//链式前向星存边
{
    int to,value;
}EDGE;
const int INF = 0x3f3f3f3f;//无穷大
void Solve()
{
    int n,m,x,y,v;
    cin >> n >> m;
    int dis[n+1];
    vector<EDGE> e[n+1];
    bool vis[n+1];//标记数组,防止重复入队,TLE
    int cnt[n+1];//记录最短路包含的边数,最多为n-1,否则就说明有负环
    memset(dis,0x3f,sizeof(dis));//一系列初始化
    memset(vis,0,sizeof(vis));
    memset(cnt,0,sizeof(cnt));
    dis[1] = 0;//初始化
    for (int i = 1;i<=m;i++)//建图
    {
        cin >> x >> y >> v;
        if (v>=0)
        {
           e[x].push_back({y,v});
           e[y].push_back({x,v});
        }
        else
        {
            e[x].push_back({y,v});
        }
    }
    queue<int> que;
    que.push(1);
    vis[1] = true;//标记
    while (!que.empty())
    {
        x = que.front();
        que.pop();
        vis[x] = false;//取消标记
        for (auto v : e[x])//遍历与当前点连接的边
        {
            if(dis[v.to] > dis[x] + v.value)//更新最短路
            {
                dis[v.to] = dis[x] + v.value;
                cnt[v.to] = cnt[x] + 1;//累加包含的边
                if(cnt[v.to] >= n)//判断负环
                {
                    cout < "YES" << "\n";//存在输出
                    return;//返回
                }
                if(!vis[v.to])//如果没入队
                {
                    vis[v.to] = true;//标记
                    que.push(v.to);//入队
                }
            }
        }
    }
    cout << "NO" << "\n";//输出
}
```

### 连通性问题

#### 一，强连通分量(有向图Tarjan缩点)

```cpp
vector<int> e1[MAXN]; // 原图
vector<int> e2[MAXN]; // 缩点后的图
int a[MAXN],b[MAXN];

// Tarjan相关变量
int dfn[MAXN],low[MAXN],dfncnt;
int scc[MAXN],sc;
bool vis[MAXN];
stack<int> s;

int in[MAXN];

void Tarjan(int x)
{
    dfn[x] = low[x] = ++dfncnt;
    vis[x] = true;
    s.push(x);
    for (auto to : e1[x])
    {
        if (!dfn[to])
        {
            Tarjan(to);
            low[x] = min(low[x],low[to]);
        }
        else if (vis[to]) low[x] = min(low[x],dfn[to]);
    }
    if (low[x] == dfn[x])
    {
        sc++;
        while (true)
        {
            int temp = s.top();
            s.pop();
            vis[temp] = false;
            scc[temp] = sc;
            b[sc] += a[temp];
            if (temp == x) break;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e1[x].push_back(y);
    }
    for (int i = 1; i <= n; i++)
    {
        if (!scc[i]) Tarjan(i);
    }
    for (int i = 1; i <= n; i++) // 建立新图
    {
        for (auto to:e1[i])
        {
            if (scc[to] == scc[i]) continue;
            e2[scc[i]].push_back(scc[to]);
            in[scc[to]]++;
        }
    }
    return 0;
}
```

#### 二，割点

```cpp
vector<int> e[20005];
int dfn[20005],low[20005],dfncnt;
bool flag[20005];
int res;
void Tarjan(int x,int fa)
{
    dfn[x] = low[x] = ++dfncnt;
    int child = 0; // 用于处理起点的
    for (auto to : e[x])
    {
        if (to == fa) continue;
        if (!dfn[to])
        {
            child++;
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[x] == false&&x != fa&&low[to] >= dfn[x])
            {
                res++;
                flag[x] = true;
            }
        }
        else low[x] = min(low[x],dfn[to]);
    }
    if (x == fa&&child >= 2&&flag[x] == false) // 特判起点的
    {
        res++;
        flag[x] = true;
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    for (int i = 1; i <= n; i++)
    {
        if (!dfn[i]) Tarjan(i,i);
    }
    cout << res << "\n";
    for (int i = 1; i <= n; i++)
    {
        if (flag[i]) cout << i << " ";
    }
    return 0;
}
```

#### 三，割边(桥)

```cpp
void Tarjan(int x,int fa)
{
    dfn[x] = low[x] = ++dfncnt;
    for (auto v : e1[x])
    {
        int pos = v.first; // 获取编号
        int to = v.second;
        if (to == fa) continue;
        if (!dfn[to])
        {
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[pos] == false && low[to] > dfn[x]) flag[pos] = true;
        }
        else low[x] = min(low[x],dfn[to]);
    }
}
```

#### 四，双连通分量(无向图Tarjan缩点)

```cpp
//解释为什么要编号求桥：如1->2为桥，以前仅标记了1->2，虽然缩点的时候1->2无法到，但是2->1却可以，故产生错误
vector<pair<int,int>> e1[MAXN]; // 要以编号的形式记录边，否则会得到错误的缩点
vector<int> e2[MAXN]; // 缩点后的新图
int dfn[MAXN],low[MAXN],dfncnt;
bool flag[MAXN]; // 判断边编号是否未桥
int scc[MAXN],sc; // 缩点数组，有点像强连通分量

void Tarjan(int x,int fa) // Tarjan找桥
{
    dfn[x] = low[x] = ++dfncnt;
    for (auto v : e1[x])
    {
        int pos = v.first;
        int to = v.second;
        if (to == fa) continue;
        if (!dfn[to])
        {
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[pos] == false && low[to] > dfn[x]) flag[pos] = true; // 判断依据，标记边的编号
        }
        else low[x] = min(low[x],dfn[to]);
    }
}
void DFS(int x,int fa) // 边双缩点
{
    scc[x] = sc; // 记录缩点后的节点编号
    for (auto v : e1[x])
    {
        int pos = v.first;
        int to = v.second;
        if (to == fa) continue;
        if (flag[pos] || scc[to]) continue; // 如果是桥或者已经在连通块中
        DFS(to,x);
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e1[x].push_back({i,y});
        e1[y].push_back({i,x});
    }
    for (int i = 1; i <= n; i++) // 无向图求割边
    {
        if (!dfn[i]) Tarjan(i,i);
    }
    for (int i = 1; i <= n; i++) // 双连通分量边缩点
    {
        if (!scc[i]) // 如果没有所属的缩点
        {
            sc++;//点数+1
            DFS(i,0);
        }
    }
    for (int i = 1; i <= n; i++) // 建立新的无向图
    {
        for (auto v : e1[i])
        {
            int to = v.second;
            if (scc[i] == scc[to]) continue;
            e2[scc[i]].push_back(scc[to]);
            // 注意只能加一次，由于双向的缘故，另一边也会通过遍历加到
            // 如果下面代码激活了，那么会超时
            //e2[scc[to]].push_back(scc[i]);
        }
    }
    return 0;
}
```

#### 五，差分约束

```cpp
//原理：利用了差分约束的不等式，其形式与跑完最短路的三角不等式类似，即任一 dis[x] <= dis[y] + w
//细节：SPFA + 超级源点 + 负环判断
#define ll long long
#define MAXN 5005
#define INF 10000000000
vector<pair<int,ll>> e[MAXN];
ll dis[MAXN]; // 最短路数组
ll cnt[MAXN]; // 最短路经过的边数
bool vis[MAXN]; // 标记数组
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y,c;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) dis[i] = INF; // 初始最短路数组
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y >> c;
        e[y].push_back({x,c});
    }
    for (int i = 1; i <= n; i++) e[0].push_back({i,0}); // 建立超级源点，防止判漏负环
    dis[0] = 0; // 初始化
    vis[0] = true; // 标记
    queue<int> que;
    que.push(0);
    while (!que.empty())
    {
        x = que.front();
        que.pop();
        vis[x] = false; // 清除标记，表示不在队列中
        for (auto v : e[x])
        {
            int to = v.first;
            ll d = v.second;
            if (dis[to] > dis[x] + d) // 如果更优
            {
                dis[to] = dis[x] + d;
                cnt[to] = cnt[x] + 1;
                // 判断负环
                if (cnt[to] >= n+1) // 因为建立了一个超级源点，所以边数最多为n，而不n-1了
                {
                    cout << "NO" << "\n";
                    return 0;
                }
                if (vis[to]) continue;
                vis[to] = true;
                que.push(to);
            }
        }
    }
    // 如果要求某个范围，还可以将答案全部加上同一常数，因为差分后常数抵消，所以没有影响
    for (int i = 1; i <= n; i++) cout << dis[i] << " ";
    return 0;
}
```

#### 六，2-SAT

```cpp
//关键：同一个连通分量的真值一致
//判断原理：矛盾（真值不能一样的事件）的两个命题不能在同一个连通分量里
//输出方案原理：如果变量 x 的拓扑序在 x' 之后，那么取 x 值为真；而Tarjan缩点生成的是反拓扑序
#define MAXN 1000005
int dfn[MAXN<<1],low[MAXN<<1],dfncnt;
int scc[MAXN<<1],sc;
bool vis[MAXN<<1];
stack<int> s;
vector<int> e[MAXN<<1];
void Tarjan(int x) // Tarjan模板
{
    dfn[x] = low[x] = ++dfncnt;
    vis[x] = true;
    s.push(x);
    for (auto to : e[x])
    {
        if (!dfn[to])
        {
            Tarjan(to);
            low[x] = min(low[x],low[to]);
        }
        else if (vis[to]) low[x] = min(low[x],dfn[to]);
    }
    if (low[x] == dfn[x])
    {
        sc++;
        while (true)
        {
            int temp = s.top();
            s.pop();
            vis[temp] = false;
            scc[temp] = sc;
            if (temp == x) break;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x1,t1,x2,t2;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) // 注意建立边
    {
        cin >> x1 >> t1 >> x2 >> t2;
        e[x1 + n*t1].push_back(x2 + n*(t2^1)); // 如果左边要求不满足，那么一定要满足右边要求
        e[x2 + n*t2].push_back(x1 + n*(t1^1)); // 反过来
    }
    for (int i = 1; i <= 2*n; i++) // Tarjan求强连通，每个点都被求了，即使不出现在矛盾中
    {
        if (!scc[i]) Tarjan(i);
    }
    for (int i = 1; i <= n; i++) // 判断是否有解
    {
        if (scc[i] == scc[i+n]) // 矛盾(指的是对立事件)在同一连通分量
        {
            cout << "IMPOSSIBLE" << "\n";
            return 0;
        }
    }
    cout << "POSSIBLE" << "\n";
    for (int i = 1; i <= n; i++) // 当x桶拓扑序在(x)' 后时取true，而scc为反拓扑序
    {
        if (scc[i] < scc[i + n]) cout << 1 << " "; // 拓扑序在后
        else cout << 0 << "\n";
    }
    return 0;
}
```

#### 七，欧拉图

##### 有向图的欧拉路径(欧拉回路)

```cpp
//必要条件：变成无向图后图连通，本题保证了，故不用判断
#include <bits/stdc++.h>
#define MAXN 200005
using namespace std;
vector<int> e[MAXN];
int pos[MAXN]; // 记录遍历到当前节点的哪条出边了
stack<int> ans;
int in[MAXN],out[MAXN]; // 记录入度与出度
void DFS(int x) // 核心DFS
{
    for (int i = pos[x]; i < e[x].size(); i = pos[x]) // 注意这里不能i++，只能i = pos[x],因为pos[x]可能会在递归过程中变化
    {
        pos[x]++;
        DFS(e[x][i]);
    }
    ans.push(x); // 最后才入栈
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        in[y]++;
        out[x]++;
    }
    for (int i = 1; i <= n; i++) sort(e[i].begin(),e[i].end()); // 题目要求输出路径字典序，故排序

    int s = 1; // 记录起点，初始化为1，因为如果存在欧拉回路，每个点都可以是起点，字典序最小出发
    bool flag = true; // 判断存在欧拉回路
    bool have[2] = {0,0}; // 判断欧拉路径的起点与终点，用于判断欧拉路径
    for (int i = 1; i <= n; i++)
    {
        if (in[i] == out[i]) continue; // 欧拉回路判断条件
        flag = false; // 不存在欧拉回路

        if (out[i] - in[i] == 1) // 出度比入度大1，为起点
        {
            s = i;
            have[0] = true;
        }
        else if (in[i] - out[i] == 1) // 终点
        {
            have[1] = true;
        }
        else // 不存在欧拉路径
        {
            cout << "No" << "\n";
            return 0;
        }
    }
    if (!flag && (have[0] == false || have[1] == false)) // 如果即无欧拉回路也无欧拉路径
    {
        cout << "No" << "\n";
        return 0;
    }
    DFS(s);
    while (!ans.empty()) // 倒序输出即为答案
    {
        cout << ans.top() << " ";
        ans.pop();
    }
    return 0;
}
```

##### 无向图的欧拉路径(欧拉回路)

```cpp
//背景：暑假学习，无向图的欧拉路径模板
#define MAXN 505
int e[MAXN][MAXN]; // 邻接矩阵存图，便于字典序输出
int pos[MAXN]; // 用于非邻接矩阵存图的字典序输出（本模板中无用）
int cnt[MAXN]; // 记录每个点的度数
int oddp[MAXN]; // 记录奇数度数的点
int tot; // 记录奇数度数的点的数量
stack<int> ans; // 记录答案

void DFS(int x) // 核心DFS
{
    for (int i = 1; i <= 500; i++)
    {
        if (e[x][i]) // 有边没走
        {
            e[x][i]--; // 双向都要减
            e[i][x]--;
            DFS(i);
        }
    }
    ans.push(x); // 记录
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int m,s = 99999999,x,y;
    cin >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        s = min(s,x); // 找最小起点
        s = min(s,y);
        e[x][y]++;
        e[y][x]++;
        cnt[x]++; // 累加度数
        cnt[y]++;
    }
    for (int i = 1; i <= 500; i++)
    {
        if (cnt[i]%2) // 奇数入度
        {
            oddp[++tot] = i;
        }
    }
    if (tot != 2 && tot) // 如果存在奇数入度的点，且不为2个，则无欧拉路径
    {
        //虽然题目保证了有，但是作为模板还是很有必要的
        cout << "No solution!" << "\n";
    }
    int b;
    if (tot) // 存在奇数度数，则要找起点
    {
        b = min(oddp[1],oddp[2]);
    }
    else // 否则存在欧拉回路，随便
    {
        b = s; // 取字典序最小的
    }
    DFS(b);
    while (!ans.empty())
    {
        cout << ans.top() << "\n";
        ans.pop();
    }
    return 0;
}
```
