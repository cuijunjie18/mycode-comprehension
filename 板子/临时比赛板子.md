# 数据结构

## ST表

```cpp
int lg[100001];
int f[100001][30];//核心倍增数组,意思为[x,x + 2^i - 1]区间内的最大值   更好理解:以x为起点,长度为2^i的区间
void prework()
{
    lg[1] = 0;
    for (int i = 2; i <= 100000; i++) lg[i] = lg[i/2] + 1;
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();//预处理一定不能忘记了
    int n,m,l,r;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> f[i][0];
    for (int i = n; i >= 1; i--)//倒着枚举,确保了前面的所有在范围内的情况已经遍历
    {
        for (int j = 1; i + (1 << j) - 1 <= n; j++)
        {
            f[i][j] = max(f[i][j-1],f[i+(1<<(j-1))][j-1]);//dp转移
        }
    }
    while(m--)
    {
        cin >> l >> r;
        int ans = 0;
        int temp = lg[r-l+1];
        ans = max(f[l][temp],f[r-(1<<temp)+1][temp]);
        cout << ans << "\n";
    }
    return 0;
}
```

## 单调栈

```cpp
int f[3000001];//x位置的第一个大于它的位置
int a[3000001];//x位置的数的大小
stack<int> s;//栈模拟单调栈,注意!!!此题存储的位置而不是数大小
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int n;
    cin>>n;//输入数组大小
    for (int i = 1;i<=n;i++) cin>>a[i];//输入
    for (int i = n;i>=1;i--)//从后面开始扫描
    {
        while(!s.empty()&&a[s.top()] <= a[i]) s.pop();//维护单调栈
        f[i] = s.empty()?0:s.top();//如果不空则第一个比它大的位置为栈顶,否则为0(即没有比它大的)
        s.push(i);//当前位置入栈
    }
    for (int i = 1;i<=n;i++) cout<<f[i]<<" ";//输出
    return 0;
}
```

## 单调队列

```cpp
int a[2000001];//记录原始数据
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int n,m;
    deque<int> que;//建立双端队列,存储的是位置信息
    cin>>n>>m;
    for (int i = 1;i<=n;i++) cin>>a[i];//输入原始数据
    cout<<0<<"\n";//第一个数前面肯定没有数,输出0
    for (int i = 2;i<=n;i++)//处理剩余n个位置
    {
        if(!que.empty()&&que.front()<i-m) que.pop_front();//超过限定窗口大小的出队
        while(!que.empty()&&a[i-1] < a[que.back()]) que.pop_back();//求最小值维护单调上升的队列
        que.push_back(i-1);//当前位置前一位入队
        cout<<a[que.front()]<<"\n";//输出此时队头即为答案
    }
    return 0;
}
```

## 树状数组求逆序对

```cpp
typedef struct situation//数的信息结构体
{
    int num,pos;
}SI;
int tree[500001];//树状数组
SI a[500001];//数据
int n;//数据的大小
int lowbit(int x)//截取低位1代表的10进制数
{
    return x&(-x);
}
void add(int p,int x)//单点修改
{
    while(p<=n)//注意范围
    {
        tree[p] += x;
        p += lowbit(p);
    }
}
int getsum(int x)//区间求和
{
    int ans = 0;
    while(x>=1)
    {
        ans += tree[x];
        x -= lowbit(x);
    }
    return ans;//返回答案
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    set<int> s;
    map<int,int> check;
    long long ans = 0;
    cin>>n;
    for (int i = 1;i<=n;i++)//预处理
    {
        cin>>a[i].num;
        s.insert(a[i].num);//插入
    }
    int cnt = 0;//记录非重复数的数量
    for (auto v:s) check[v] = ++cnt;//记录每个数的排位
    for (int i = 1;i<=n;i++) a[i].pos = check[a[i].num];//将每个数获取它的位置
    for (int i = 1;i<=n;i++)//顺序输入维护动态过程
    {
        ans += getsum(cnt) - getsum(a[i].pos);//放入新数之前累加答案
        add(a[i].pos,1);//单点修改
    }
    cout<<ans<<"\n";//输出答案
    return 0;
}
```

## 归并排序求逆序对

```cpp
int temp[500001];//全局辅助数组(即临时存储数据)
long long ans;//逆序对数量
void my_merge(int a[],int s1,int b[],int s2)//合并有序队列
{
    int k = 0,i = 0,j = 0;
    while(i<s1&&j<s2)
    {
        if(a[i] <= b[j]) temp[k] = a[i++];
        else
        {
            temp[k] = b[j++];
            ans += (s1-i);//累加逆序对
        }
        k++;
    }
    for (;i<s1;i++,k++) temp[k] = a[i];
    for (;j<s2;j++,k++) temp[k] = b[j];
}
void merge_sort(int a[],int l,int r)//归并排序
{
    if(r-l<=1)
    {
        if(l>=r) return;
        if(a[r] < a[l])//特殊处理
        {
            swap(a[r],a[l]);
            ans++;//累加逆序对
        }
        return;
    }
    int mid = (l+r)>>1;
    merge_sort(a,l,mid-1);
    merge_sort(a,mid,r);
    my_merge(&a[l],mid-l,&a[mid],r-mid+1);
    for (int i = l;i<=r;i++) a[i] = temp[i-l];
}
int main()
{
    int n;
    cin>>n;
    int a[n+1];
    for (int i = 1;i<=n;i++) cin>>a[i];
    merge_sort(a,1,n);
    cout<<ans<<"\n";//输出
    return 0;
}
```

## 并查集

### 带权并查集

```cpp
int f[30002];//记录对应数的祖先
int d[30002];/*记录每个点到根节点的距离（并不是全过程都是到他祖先距离，而是到其父亲距离，只不过后面递归回溯改变了父亲为
                  祖先*/
int big[30002];//记录集合大小
int Find(int x)//神来之笔，查找祖先及计算距离
{
    if(x == f[x]) return x;//如果是根节点，返回
    int k = Find(f[x]);//先找到根节点
    d[x] += d[f[x]];//回溯更新对应点到根节点距离
    return f[x] = k;//路径压缩
}
void Join(int a,int b)//常规并查集合并模板
{
    int f1 = Find(a);
    int f2 = Find(b);
    f[f1] = f2;
    d[f1] = big[f2];//改变距离，关键
    big[f2] += big[f1];
}
int main()
{
    for (int i = 1;i<=30000;i++)//初始化
    {
        f[i] = i;
        big[i] = 1;
        d[i] = 0;
    }
    int t,a,b;
    char ch;
    scanf("%d",&t);
    while(t--)
    {
        scanf(" %c",&ch);
        if(ch == 'M')
        {
            scanf("%d%d",&a,&b);
            Join(a,b);//合并集合
        }
        else
        {
            scanf("%d%d",&a,&b);
            if(Find(a)!=Find(b)) printf("-1\n");
            else
            {
                printf("%d\n",abs(d[a]-d[b]) - 1);
            }
        }
    }
    return 0;
}
```

#### 种类并查集

```cpp
int f[2010];//集合大小定义为人数的两倍，另一半充当虚拟敌人(比如a+n就代表a+n是敌人，谁连接了a+n就表示谁以a为敌人)
set <int> s;//不重复数字，用于判断朋友关系数量，即团体个数（本质：有多少个祖先代表有多少个集合）
int Find(int x)//查找祖先加路径压缩
{
    if(x == f[x]) return x;
    else return f[x] = Find(f[x]);
}
void Join(int a,int b)//合并集合
{
    int f1 = Find(a);
    int f2 = Find(b);
    if(f1 == f2) return;
    f[f2] = f1;
}
int main()
{
    int n,m,a,b;
    char ch;
    scanf("%d%d",&n,&m);//输入人数及关系数
    for (int i = 1;i<=2*n;i++)//初始化祖先，必不可少!!!
    {
        f[i] = i;
    }
    while(m--)//输入每条关系
    {
        scanf(" %c",&ch);
        if(ch == 'F')//如果是朋友
        {
            scanf("%d%d",&a,&b);
            Join(a,b);//直接合并
        }
        else
        {
            scanf("%d%d",&a,&b);
            Join(a+n,b);//反集合并，，（比如，若有其他人以a+n为敌人，则可以使得b与它合并成朋友关系）
            Join(b+n,a);//反集合并
        }
    }
    for (int i = 1;i<=n;i++)//计算集合个数，即祖先数
    {
        s.insert(Find(i));//不重复的祖先插入，重复不算
    }
    printf("%d\n",s.size());//输出集合个数
    return 0;
}
```

# 动态规划模板

## LIS

### logn算法

```cpp
void Solve()
{
    int n,x;
    cin>>n;
    int low[n+1];
    memset(low,0,sizeof(low));
    int ans = 0;
    for (int i = 1;i<=n;i++)
    {
        cin>>x;
        if(x > low[ans])
        {
            ans++;
            low[ans] = x;
        }
        else
        {
            int p = lower_bound(low+1,low+ans+1,x) - low;
            low[p] = x;
        }
    }
    cout<<ans<<"\n";
}
```

### LIS 方案计数

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef struct sb
{
    int a;//a为长度，即以i结尾的最长不降子序列的长度
    int way;//b为满足a长度的方案数
}SB;
SB f[21];//dp数组
int main()
{
    int m;
    cin>>m;//输入测试数据组数
    for (int i = 1;i<=m;i++)//依次处理每组测试数据
    {
        memset(f,0,sizeof(f));//重新初始化
        int n;
        cin>>n;//输入该组测试数据的木桩数
        int number[n+1];
        for (int j = 1;j<=n;j++)//初始化
        {
            cin>>number[j];
            f[j].a = 1;
            f[j].way = 1;
        }
        int ans = 0;//最大长度初始化
        int allway = 0;//方案数初始化
        for (int j = 2;j<=n;j++)//dp
        {
            for (int k = 1;k<=j-1;k++)
            {
                if(number[j]>=number[k])//如果可以接上
                {
                    if(f[k].a + 1>f[j].a)//有更大的值了
                    {
                        f[j].a = f[k].a + 1;//更新最大值
                        f[j].way = f[k].way;//重新计算方案数
                    }
                    else if(f[k].a + 1 ==  f[j].a)//如果等于
                    {
                        f[j].way += f[k].way;//增加方案数
                    }
                }
                ans = max(ans,f[j].a);//答案取最大值
            }
        }
        for (int j = 1;j<=n;j++)//找符合最大值的方案数
        {
            if(f[j].a == ans) allway += f[j].way;//如果等于答案，方案数累加
        }
        cout<<ans<<" "<<allway<<endl;//输出
    }
    return 0;
}
```

## LCS

### 朴素o(n^2)

```cpp
int f[1001][1001];//dp数组,f[i][j]为处理了a的前i位,b的前j位得到的最长公共子序列
int a[1001];
int b[1001];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int n;
    cin>>n;
    for (int i = 1;i<=n;i++) cin>>a[i];
    for (int i = 1;i<=n;i++) cin>>b[i];
    for (int i = 1;i<=n;i++)//dp,处理f[i][j]
    {
        for (int j = 1;j<=n;j++)
        {
            if(a[i] == b[j]) f[i][j] = f[i-1][j-1] + 1;//如果当前a[i] == b[j],则可以长度加1
            else f[i][j] = max(f[i-1][j],f[i][j-1]);//否则转移最大值(观察下标,之前的已经计算过了)
        }
    }
    cout<<f[n][n]<<"\n";//输出答案
    return 0;
}
```

### 化为LIS

```cpp
//适用条件:两个序列元素互异且相同,便可以转化为LIS问题
/*我的解释:map记录下b[]的每个元素的位置,然后利用a[]得到一个在b中对应元素的位置序列cvt[],为什么可以转化为LIS问题呢?
  不妨以a[5] = [3 2 1 4 5],b[5] = [1 2 3 4 5],得到的cvt数组为cvt[5] = [3,2,1,4,5],当然你a,b数组可以反着来操作,无所谓
  不妨取cvt中对应一个位置为假设LCS的起点,因为LCS是按顺序来的,那么比起点小的位置均无效,那么除去该起点及所有比起点小的位置,剩下的
  情况转换成了一个子问题重复,故动态规划解.而起点又又多个选择,故变成找最长的上升子序列了.故LCS->LIS合理*/
#include <bits/stdc++.h>
using namespace std;
unordered_map<int,int> b;//用哈希表不一定有红黑树快,对于可能卡哈希的,而红黑树一定过的,优先用红黑树(acmer的严谨,我这里不管)
int a[100001];//a数组
int cvt[100001];//转换得到的cvt数组
int low[100001];//长度为i的LIS的最后一个数的最小值
int m = 0;//LIS最大长度,初始化为0
int Find(int x)//二分查找
{
    int ans = 0;//初始化答案
    int l = 0;
    int r = m;
    while(l<=r)//二分
    {
        int mid = (l+r)>>1;
        if(low[mid] >= x)//一定要等于,否则就不满足LIS性质了(即单调上升,可能会导致单调不减)
        {
            ans = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    memset(low,-127,sizeof(low));//low数组初始化为负无穷,防止新的数比low[1]还小的情况的Hack!(自己感悟)
    int n,x;
    cin>>n;//输入数量
    for (int i = 1;i<=n;i++) cin>>a[i];//输入a数组
    for (int i = 1;i<=n;i++)//处理b数组
    {
        cin>>x;
        b[x] = i;//记下位置
    }
    for (int i = 1;i<=n;i++)//生成cvt数组
    {
        cvt[i] = b[a[i]];
    }
    for (int i = 1;i<=n;i++)//LIS模板
    {
        if(cvt[i]>low[m]) low[++m] = cvt[i];//直接接上
        else
        {
            int p = Find(cvt[i]);
            low[p] = cvt[i];//更新位置最小值
        }
    }
    cout<<m<<"\n";//输出答案,即LIS长度
    return 0;
}
```

## 区间dp

```cpp
int fd[300][300];//存储最下代价和
int fu[300][300];//存储最大代价和
int sum[300];//前缀和数组
int number[110];//每个数字
int n;//数字个数
int ansd,ansu;//答案
int main()
{
    cin>>n;//输入数字个数
    memset(fd,0x3f,sizeof(fd));//求最小值的要初始化为正无穷
    ansd = fd[0][0];//最小值的答案初始化为正无穷
    ansu = 0;//最大值的答案初始化为0
    for (int i = 1;i<=n;i++)//输入每个数字
    {
        cin>>number[i];//输入数字
        sum[i] = sum[i-1] + number[i];//维护前缀和
        fd[i][i] = 0;//初始化，自己合成代价为0
        fu[i][i] = 0;//初始化，自己合成代价为0
    }
    for (int i = n+1;i<=2*n;i++)//在后面接上之前的至今完整接完一个周期
    {
        sum[i] = sum[i-1] + number[i-n];//接上形成环状
        fd[i][i] = 0;//初始化
        fu[i][i] = 0;//初始化
    }
    for (int i = 2;i<=n;i++)//枚举区间长度
    {
        for (int b = 1;b+i<=2*n;b++)//哪怕有重复，是为后面服务，我原来是b<=n(自己思考)
        {
            int e = b + i - 1;
            for (int k = b;k<e;k++)//枚举区间分割点
            {
                fd[b][e] = min(fd[b][e],fd[b][k] + fd[k+1][e] + sum[e] - sum[b-1]);//取最小值
                fu[b][e] = max(fu[b][e],fu[b][k] + fu[k+1][e] + sum[e] - sum[b-1]);//取最大值
            }
        }
    }
    for (int i = 1;i<=n;i++)//枚举长度为n时d起点位置
    {
        if(fd[i][i+n-1]<ansd) ansd = fd[i][i+n-1];//取最小值
        if(fu[i][i+n-1]>ansu) ansu = fu[i][i+n-1];//取最大值
    }
    cout<<ansd<<endl;//输出
    cout<<ansu<<endl;//输出
    return 0;
}
```

## 状压dp(含子集枚举)

```cpp
#include <bits/stdc++.h>
using namespace std;
int w[17],t[17];//记录每个人的重量及过桥时间
int g[17];//记录每个人对应的二进制状态,美化代码
int dp[1<<16],W[1<<16],T[1<<16];//记录对应状态的答案最小值,体重和,时间最大值
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int m,n;
    cin>>m>>n;
    for (int i = 1;i<=n;i++) g[i] = (1<<(i-1));//记录对应编号的二进制状态
    for (int i = 1;i<=n;i++) cin>>t[i]>>w[i];//输入时间与体重
    for (int i = 1;i<=(1<<n)-1;i++)//枚举状态,记录数据
    {
        for (int j = 1;j<=n;j++)//枚举该状态下的人
        {
            if((i&g[j]) == 0) continue;//如果不在,跳过
            T[i] = max(T[i],t[j]);//否则取时间最大值
            W[i] = W[i^g[j]] + w[j];//体重求和
        }
    }
    memset(dp,127,sizeof(dp));//求最小值,初始化为正无穷
    dp[0] = 0;//难理解,dp的边界处理,没有人过桥时间最小值当然是0
    for (int i = 1;i<=(1<<n)-1;i++)//枚举状态
    {
        for (int j = i;;j = (j-1)&i)//枚举子集进行状态切割(子集认为是已经满足条件的了,或者说已经分好最优的组了,目的是让切割出来的为一组试试)
        {
            if(W[i^j] <= m) dp[i] = min(dp[i],dp[j]+T[i^j]);//如果切割出的状态体重和不超,利用切割出的状态进行dp
            if(j == 0) break;//这里放在上一行代码后目的是处理单个人的状态
        }
    }
    cout<<dp[(1<<n)-1]<<"\n";//输出答案
    return 0;
}
```

# 数学

## 前缀和与差分

### 多维前缀和

```cpp
// 预处理前缀和
sum[i][j] = x + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];

// 求(x1,y1)左上角到(x2,y2)右下角的矩形的和
ans = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]
```

### 多维差分

```cpp
// (x1,y1)为左上角，(x2,y2)为右下角，c为填加值
void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x1][y1] += c;
    b[x2+1][y1] -= c;
    b[x1][y2+1] -= c;
    b[x2+1][y2+1] += c;
}
```

## 进制

### 进制转换(含负进制)：十进制转任意进制

```cpp
//难点:负数进制如何表示，如何避免出现余数为负数的
/*原理:任何一个数有,被除数=除数*商+余数，例如-15%-2 = -1,-15/-2 = 7; 7*(-2) + (-1) = -15为c++中负数的余数，而我们要的进制位上为正数
有(商+1)*除数 + (余数-除数) = 商*除数+除数+余数-除数 = 被除数，故可以把该式等价原式，令新的余数为余数-除数，新的剩余被除数为原剩余被除数+除数*/
#include <bits/stdc++.h>
using namespace std;
int num[101];//位运算数组
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);//输入n及对应进制
    int len = 0;//初始化位数
    int save = n;//保存原被除数
    while (n)//进制转换
    {
        num[++len] = n%k;//取余数
        if (n%k<0)//如果余数<0，转换为正数
        {
            num[len] = n%k-k;//减除数
            n += k;//剩余被除数要加上一个除数
        }
        n /= k;//进位继续
    }
    printf("%d=",save);//输出
    for (int i = len; i >= 1; i--)//按位输出
    {
        if(num[i] >= 10) printf("%c",num[i]-10+'A');//超过9的部分转换为字母
        else printf("%d",num[i]);
    }
    printf("(base%d)",k);
    return 0;
}

```

### 待补充

## 数论

### 最大公约数(gcd)与最小公倍数(lcm)

#### 最大公约数求法

```cpp
// 内置函数
gcd = __gcd(a,b) // 不能有0

//自定义函数(兼容0)，条件：初始时gcd(a,b),a < b
int gcd(int a,int b)
{
    if (!b) return a;
    return gcd(b,a%b);
}
```

#### 最小公倍数求法

```cpp
ans = a*b/__gcd(a,b)
```

### 质数筛法

#### 埃式筛：o(nloglogn)

```cpp
// num为bool型
void Prime()
{
    num[1] = 1;//1不是质数
    for (int i = 2; i*i <= 1000001; i++)//i*i减少时间复杂度，自己仔细想想（但这样不能顺序记录范围内所有素数）
    {
        if(!num[i])//如果没被筛过，说明这个数是素数，筛掉它的倍数
        {
            for (int j = i*i; j <= 1000001; j += i)//从i*i开始，保证时间复杂度
            num[j] = 1;
        }
    }
}
```

#### 欧拉筛：o(n)

```cpp
// 原理：利用了每个合数都有一个最小质因数
void Eulerprime(int n)
{
    number[1] = 1;//1不是素数
    for (int i = 2; i <= n; i++)
    {
        if(!number[i])
        {
            pos++;//素数个数加1
            prime[pos] = i;//记录新素数
        }
        for (int j = 1; j<=pos && i*prime[j] <= n; j++)
        {
            number[i*prime[j]] = 1;//筛掉以prime[j]为最小质因数的合数
            if(i%prime[j] == 0) break;//如果i是由prime[j]得来的，则后面i的乘全都可以通过它来筛，减少重复(后面必然会筛掉)
        }
    }
}
```

#### 区间素数筛

```cpp
long long prime[5001];//可以用的素数
bool number[50001];//判断素数1
bool vis[1000005];//判断素数2
int cnt;//预处理出的素数个数
void prework()//欧拉筛筛选出可用的质数
{
    number[1] = 1;
    for (int i = 2;i<=50000;i++)
    {
        if(!number[i]) prime[++cnt] = i;
        for (int j = 1;j<=cnt&&i*prime[j]<=50000;j++)
        {
            number[i*prime[j]] = 1;
            if(i%prime[j] == 0) break;
        }
    }
}
int main()
{
    prework();//欧拉筛准备工作
    int l,r;
    cin>>l>>r;
    int ans = 0;//初始化答案
    for (int i = 1;i<=cnt;i++)//区间筛
    {
        long long p = prime[i];
        long long start = max((long long)(2),(l + p - 1)/p)*p;//难点:(l+p-1)/p为ceil(l/p),即向上取整,max为2的作用防止出现1将自己筛掉
        for (long long j = start;j<=r;j += prime[i]) vis[j-l+1] = true;//标记为合数
    }
    for (int i = 1;i<=r-l+1;i++)
    {
        if(vis[i]) continue;
        ans++;
    }
    if(l == 1) ans--;//特判1,因为上述过程中无法筛掉1
    cout<<ans<<endl;
    return 0;
}
```

### 逆元

#### 快速幂

```cpp
long long quickpow(long long a,int b,int p)
{
    if (a == 0) return 0; // 防止底数为0，0取模错误
    long long ans = 1;
    while (b)
    {
        if(b & 1) ans = ans * a % p;
        a = a * a % p;//此次为a必须开long long 原因
        b = b >> 1;
    }
    return ans;
}
```

#### 快速幂求逆元(要保证mod为质数)

```cpp
int Powmod(int a,int b,int mod)
{
    int ans = 1;
    while (b)
    {
        if(b & 1) ans = ans * a % mod;//注意要取模(若模数过大开long long)
        a = a * a % mod;//注意要取模
        b >>= 1;
    }
    return ans;
}
int main()
{
    int n,b;
    scanf("%d%d",&n,&b);
    for (int i = 1; i <= n; i++)
    {
        int ans = Powmod(i,b-2,b);
        printf("%d\n",ans);
    }
    return 0;
}
```

#### 拓展欧几里得求逆元(Exgcd)

```cpp
void GCD(int a,int b,int &x,int &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    GCD(b,a%b,x,y);
    int temp = x;
    x = y;
    y = temp - a/b*y;
}
int EXGCD(int a,int b)
{
    int x,y;
    GCD(a,b,x,y);
    return x;
}
int main()
{
    int a,b,d;//要求a模b的逆元d
    scanf("%d%d",&a,&b);
    d = (EXGCD(a,b)%b + b)%b;//保证逆元为正数
    printf("%d\n",d);
    return 0;
}
```

#### 线性求逆元(即模一个数下的逆元)

```cpp
long long inv[30000000];//存储1到30000000模某个特定值的逆元
int main()
{
    int a,b;//求1到a模b的逆元,注意b要大于a，一般b为大于a的素数
    scanf("%d%d",&a,&b);
    inv[0] = inv[1] = 1;
    for (int i = 2;i<=a;i++)
    {
        inv[i] = (b - (b/i))*inv[b%i]%b;
    }
    for (int i = 1;i<=a;i++)
    {
        printf("%lld\n",inv[i]);
    }
    return 0;
}
```

## 组合数学

### 组合数问题

#### 杨辉三角预处理组合数

```cpp
int n,m;
int f[1005][1005];//f[i][j]表示从i个数里选j个数的方案数
int main()
{   
    cin>>n>>m;
    for(int i = 0; i <= n; i++)//一定要从0开始
    {
        f[i][i] = 1;
        f[i][0] = 1;
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j<i; j++)
            f[i][j] = f[i-1][j] + f[i-1][j-1];//状态转移方程
    cout << f[n][m];
    return 0;
}
```

#### 公式法求组合数(通常数很大，结合逆元)

```cpp
//时间复杂度:o(n)
const int md = 998244353;//模数
long long f[5000001];//预处理阶乘
long long inv[5000001];//先用于预处理每个数的逆元，后用于求每个阶乘的逆元
int main()
{
    f[0] = f[1] = inv[1] = inv[0] = 1;//初始化，！！！inv[0] 一定要为1
    for (int i = 2;i<=5000000;i++)//预处理
    {
        f[i] = f[i-1]*i%md;
        inv[i] = (md - md/i)*inv[md%i]%md;//线性求逆元
    }
    for (int i = 2;i<=5000000;i++)//求阶乘的逆元，原理为乘积的逆元等于逆元的乘积
    {
        inv[i] = inv[i-1]*inv[i]%md;//处理阶乘值的逆元，若无阶乘逆元处理，就会MLE，因为(n-m)!*m%md的逆元范围上界是md
    }
    c[n][m] = f[n]*inv[m]%md*inv[n-m]%md; // c[n][m]为n个数里选m个
    cout << c[n][m] << "\n";
    return 0;
}
```

### 错排列(递推式)

```cpp
int d[10];
int main()
{
    //舍弃了D(0),对D(1) 与 D(2)赋初值 
    d[1] = 0;
    d[2] = 1;
    for (int i = 3;i<=10;i++)
    {
        d[i] = (i-1)*(d[i-2] + d[i-1]);
    }
    for (int i = 0;i<=10;i++) cout<<d[i]<<endl;
    return 0;
}
```

### 卡特兰数

1,第n项的通项公式为 f(n) = $ C^n_2n – C^{n+1}_{2n} = C_{2n}^n/(n+1) $
2,第n项的递推公式为f(n) = f(n-1)*(4n-2)/(n+1) //其中涉及除法,有取模运算的时候就不行了
3,卡特兰数定义式f[n] = f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-1]*f[0]
4,卡特兰数的一般情况：f[n+m] = $ C_{n+m}^n- C_{n+m}^{n+1} $
注意(1)其中f(0) = f(1) = 1
    (2)注意理解题目中的n与2n

# 图论

## 树上问题

### 树的重心

#### 一般树的重心

```cpp
//通过判断最大子树求重心
void getrt(int x,int fa) // 获取树的重心
{
    big[x] = 1;
    maxn[x] = 0; // 初始化最大子树大小
    for (auto v : e[x])
    {
        int to = v.first;
        if (to == fa || vis[to]) continue; // 注意vis
        getrt(to,x);
        big[x] += big[to];
        maxn[x] = max(big[to],maxn[x]);
    }
    maxn[x] = max(maxn[x],sum - big[x]);
    if (maxn[x] < maxn[rt]) rt = x;
}
```

#### 带权树的重心

```cpp
typedef struct edge//边结构体
{
    int to,next;
}EDGE;
EDGE e[100001<<1];
int head[100001];
int cnt;

long long c[100001];//点权
long long big[100001];//以i为根节点树的大小
long long m[100001];//i的最大子树的大小
long long all;//记录整棵树的大小

int n;//节点数
int p;//重心编号
long long ans;//答案
void add(int x,int y)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void DFS(int x,int fa)//找重心
{
    big[x] = c[x]; // 初始化为点权
    for (int i = head[x]; i; i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
        big[x] += big[e[i].to];
        m[x] = max(m[x],big[e[i].to]);
    }
    m[x] = max(m[x],all-big[x]);//取最大连通块
    if(m[x] <= all/2) p = x;//判断重心
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int x,y;
    cin >> n;
    for (int i = 1; i<=n-1; i++)//建树
    {
        cin >> x >> y;
        add(x,y);
        add(y,x);
    }
    for (int i = 1; i<=n; i++)//计算整棵树的大小
    {
        cin >> c[i];
        all += c[i];
    }
    DFS(1,0);//找重心
    return 0;
}
```

### 树的直径

#### 正边权情况

```cpp
typedef struct way
{
    int p,value;
}WAY;
vector <WAY> g[500001];//邻接表存图
long long d[500001];//存答案
int c;//第一次DFS的最远位置，第二次DFS的起始位置及改变后的答案
void DFS(int x,int f)
{
    for (int i = 0,k = g[x].size(); i<k; i++)
    {
        if (g[x][i].p == f) continue;
        d[g[x][i].p] = d[x] + g[x][i].value;
        if (d[g[x][i].p]>d[c]) c = g[x][i].p;//比较并更新最远点
        DFS(g[x][i].p,x);
    }
}

int main()
{
    int n,v,a,b;
    scanf("%d",&n);
    for (int i = 1; i<=n-1; i++)
    {
        scanf("%d%d%d",&a,&b,&v);
        WAY temp = {b,v};
        g[a].push_back(temp);
        temp.p = a,temp.value = v;
        g[b].push_back(temp);
    }
    DFS(1,0);//随便从一个点开始DFS
    d[c] = 0;//变回0
    DFS(c,0);//再次DFS
    printf("%lld\n",d[c]);//输出答案
    return 0;
}
```

#### 含负边权情况

```cpp
typedef struct way//定义边权结构体
{
    int p,value;
}WAY;
vector <WAY> g[500001];//邻接表存图

//d1为寻求直径路上到不同于出发点的另一端点的权值和的最优解，d2为次优解
long long d1[500001],d2[500001];

long long c;//答案
void DFS(int x,int f)
{
    d1[x] = 0,d2[x] = 0;
    for (int i = 0,k = g[x].size(); i<k; i++)
    {
        if (g[x][i].p == f) continue;
        DFS(g[x][i].p,x);
        int t = d1[g[x][i].p] + g[x][i].value;
        if (t > d1[x])//大于当前点最优解，更新最优与次优
        {
            d2[x] = d1[x];
            d1[x] = t;
        }
        else if (t > d2[x])//仅大于次优解，更新
        {
            d2[x] = t;
        }
    }
    c = max(c,d1[x] + d2[x]);//套公式，取最大值
}

int main()
{
    int n,v,a,b;
    scanf("%d",&n);
    for (int i = 1; i<=n-1; i++)
    {
        scanf("%d%d%d",&a,&b,&v);
        WAY temp = {b,v};
        g[a].push_back(temp);
        temp.p = a,temp.value = v;
        g[b].push_back(temp);
    }
    DFS(1,0);//无根树，从任意一点当作根节点出发
    printf("%lld\n",c);
    return 0;
}
```

### 最近公共祖先(LCA)

#### 倍增算法

```cpp
//可以预处理logn，但是本文无
typedef struct edge
{
    int to,next;
}EDGE;
EDGE e[500001<<1];
int head[500001];

int number;//双边总数
int depth[500001];//每个点的深度
int f[500001][30];//2^i祖先

inline int read()//快读
{
    int s = 0;
    char ch = getchar();
    while (ch<'0'||ch>'9')
    {
        ch = getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

void add(int x,int y)
{
    e[++number].to = y;
    e[number].next = head[x];
    head[x] = number;
}

void DFS(int x,int fa)//预处理LCA
{
    depth[x] = depth[fa] + 1;
    f[x][0] = fa;
    for (int i = 1; (1<<i)<=depth[x]; i++)
    {
        f[x][i] = f[f[x][i-1]][i-1];
    }
    for (int i = head[x]; i; i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
    }
}

int Solve(int a,int b)//倍增LCA
{
    if (a == b) return a;
    if (depth[a] < depth[b]) swap(a,b);
    while (depth[a] > depth[b])
    {
        a = f[a][(int)(log(depth[a]-depth[b])/log(2))];
    }
    if (a == b) return a;
    for (int i = (int)(log(depth[a])/log(2)); i>=0; i--)
    {
        {
            if(f[a][i] != f[b][i])
            {
                a = f[a][i];
                b = f[b][i];
            }
        }
    }
    return f[a][0];
}

int main()
{
    int n,m,s,a,b;
    n = read(),m = read(),s = read();
    for (int i = 1; i<=n-1; i++)
    {
        a = read();
        b = read();
        add(a,b);
        add(b,a);
    }
    depth[0] = -1;//初始化深度为-1
    DFS(s,0);//从根节点开始搜索
    for (int i = 1; i<=m; i++)
    {
        printf("%d\n",Solve(read(),read()));
    }
    return 0;
}
```

#### Tarjan离线o(n)

```cpp
typedef struct edge
{
    int to,next,v;
}EDGE;

EDGE e[500001<<1];//边数组
int head[500001];//i编号边的起点
int cnt;//边的数量
EDGE ask[500001<<1];//询问数组
int hask[500001];//i编号询问的其中一个数
int cask;//询问数组有用的数量
int f[500001];//并查集根节点数组
bool visit[500001];//标记数组
int ans[500001];//存储答案的数组，ans[i]对应第i次询问的答案

inline int read()//快读，不用说了
{
    int s = 0;
    char ch = getchar();
    while (ch < '0'||ch > '9') ch = getchar();
    while (ch <= '9'&&ch >= '0')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

int Find(int x)//并查集查找加路径压缩
{
    if (x == f[x]) return x;
    else return f[x] = Find(f[x]);
}

void add(int x,int y)//加边函数
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void adda(int x,int y,int a)//记录询问函数
{
    ask[++cask].to = y;
    ask[cask].v = a;//该两数边的询问是第a个
    ask[cask].next = hask[x];
    hask[x] = cask;
}

void DFS(int x,int fa)//一次DFS结合Tarjan求LCA
{
    for (int i = head[x];i;i = e[i].next)//遍历子树
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x);
    }
    for (int i = hask[x];i;i = ask[i].next)//遍历于该点有关的问题询问
    {
        if(ask[i].to == x)//Hack数据，如果询问是自己
        {
            ans[ask[i].v] = x;//不管visit直接记录答案，否则不会再次来到自己这个位置
            continue;//继续
        }
        if(visit[ask[i].to])//如果于该节点连接的问题的点已经到达过
        {
            ans[ask[i].v] = Find(ask[i].to);//记录答案
        }
    }
    visit[x] = true;//标记当前点
    f[x] = fa;//改变父节点
}

int main()
{
    int n = read();//读入节点个数
    int q = read();//读入询问次数
    int s = read();//读入根节点编号
    for (int i = 1;i<=n;i++) f[i] = i;//!!!!一定要初始化并查集
    for (int i = 1;i<=n-1;i++)//建树
    {
        int a = read();
        int b = read();
        add(a,b);
        add(b,a);
    }
    for (int i = 1;i<=q;i++)//建立询问的边
    {
        int a = read();
        int b = read();
        adda(a,b,i);
        adda(b,a,i);
    }
    DFS(s,0);//一次DFS加Tarjan，找到答案
    for (int i = 1;i<=q;i++)//按顺序输出对应询问的答案
    {
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

### 树上差分

#### 点差分

```cpp
vector<int> e[50005];
int cha[50005]; // 差分数组
int f[50005][35];
int depth[50005];
int logn[50005];
int ans;

void prework()
{
    logn[1] = 0;
    for (int i = 2;i<=50000;i++) logn[i] = logn[i/2] + 1;
}

void DFS(int x,int fa,int d)
{
    depth[x] = d;
    f[x][0] = fa;
    for (int i = 1;(1<<i)<=depth[x];i++) f[x][i] = f[f[x][i-1]][i-1];
    for (auto v:e[x])
    {
        if(v == fa) continue;
        DFS(v,x,d+1);
    }
}

void Count(int x,int fa)
{
    for (auto v:e[x])
    {
        if(v == fa) continue;
        Count(v,x);
        cha[x] += cha[v];
    }
    ans = max(ans,cha[x]);
}

int LCA(int a,int b)
{
    if(depth[a] < depth[b]) swap(a,b);
    while(depth[a] > depth[b]) a = f[a][logn[depth[a]-depth[b]]];
    if(a == b) return a;
    for (int i = logn[depth[a]];i>=0;i--)
    {
        if(f[a][i] != f[b][i])
        {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();
    int n,k,x,y;
    cin >> n >> k;
    for (int i = 1;i<=n-1;i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    DFS(1,0,0);
    for (int i = 1; i <= k ;i++)
    {
        cin >> x >> y;
        int lca = LCA(x,y);
        //核心差分
        cha[x]++;
        cha[y]++;
        cha[lca]--;
        cha[f[lca][0]]--;
    }
    Count(1,0);
    cout<<ans<<"\n";
    return 0;
}
```

#### 边差分

```cpp
//原理:LCA + 树上边差分
typedef struct edge
{
    int to,next,num;//num为边的号码
}EDGE;
EDGE e[100001<<1];
int head[100001];
int cnt;
int d[100001];//差分数组兼具前缀和数组
int f[100001][30];
int depth[100001];
int logn[100001];
int ans[100001];

void prework()//预处理对数数组
{
    logn[1] = 0;
    for (int i = 2;i<=100000;i++) logn[i] = logn[i/2] + 1;
}

void add(int x,int y,int c)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    e[cnt].num = c;
    head[x] = cnt;
}

void DFS(int x,int fa,int d)//预处理LCA
{
    depth[x] = d;
    f[x][0] = fa;
    for (int i = 1;(1<<i)<=depth[x];i++) f[x][i] = f[f[x][i-1]][i-1];
    for (int i = head[x];i;i = e[i].next)
    {
        if(e[i].to == fa) continue;
        DFS(e[i].to,x,d+1);
    }
}

void Count(int x,int fa,int pos)//差分求和
{
    for (int i = head[x];i;i = e[i].next)
    {
        if(e[i].to == fa) continue;
        Count(e[i].to,x,e[i].num);
        d[x] += d[e[i].to];
    }
    ans[pos] = d[x];//记录对应边的答案
}

int LCA(int a,int b)
{
    if(a == b) return a;
    if(depth[a] < depth[b]) swap(a,b);
    while(depth[a] > depth[b]) a = f[a][logn[depth[a]-depth[b]]];
    if(a == b) return a;
    for (int i = logn[depth[a]];i>=0;i--)
    {
        if(f[a][i] != f[b][i])
        {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    prework();
    int n,k,x,y;
    cin>>n;
    for (int i = 1;i<=n-1;i++)
    {
        cin>>x>>y;
        add(x,y,i);
        add(y,x,i);
    }
    DFS(1,0,0);
    cin>>k;
    for (int i = 1;i<=k;i++)
    {
        cin>>x>>y;
        int lca = LCA(x,y);
        d[x]++;
        d[y]++;
        d[lca] -= 2;
    }
    Count(1,0,0);
    for (int i = 1;i<=n-1;i++) cout<<ans[i]<<" ";//依次输出答案
    return 0;
}
```

### 树上启发式合并(dsu on tree)

```cpp
typedef struct edge
{
    int to,next;
}EDGE;

EDGE e[100001<<1];
int head[100001];
int cnt;

int color[100001];//每个节点的颜色
int colornumber;//当前颜色种类数
int all[100001];//每种颜色出现的次数

int big[100001];//以i为根节点的树的大小
int son[100001];//以i为根的树的重儿子
int ans[100001];//答案数组
int l[100001];//存储i节点的DFS序
int r[100001];//存储i节点所能遍历到的最大DFS序
int Node[100001];//记录DFS序为i的节点
int pos;//记录DFS序

inline int read()//快读
{
    int s = 0;
    char ch = getchar();
    while(ch < '0'||ch > '9') ch = getchar();
    while(ch >= '0'&&ch <= '9')
    {
        s = s*10 + ch - '0';
        ch = getchar();
    }
    return s;
}

void add(int x,int y)//建边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    head[x] = cnt;
}

void addcolor(int x)//添加节点x的颜色贡献
{
    if(all[color[x]] == 0) colornumber++;
    all[color[x]]++;
}

void delcolor(int x)//删除节点x的颜色贡献
{
    all[color[x]]--;
    if(all[color[x]] == 0) colornumber--;
}

int getans()//获取当前颜色数目
{
    return colornumber;
}

void DFS1(int x,int fa)//预处理树,时间复杂度:o(n)
{
    big[x] = 1;//初始化树的大小
    l[x] = ++pos;//更新DFS序,并记录节点x的DFS序
    Node[pos] = x;//记录当前DFS序代表的节点
    for (int i = head[x];i;i = e[i].next)//遍历子树
    {
        if(e[i].to == fa) continue;
        DFS1(e[i].to,x);
        big[x] += big[e[i].to];//更新大小
        if(son[x] == 0||big[e[i].to] > big[son[x]]) son[x] = e[i].to;//更新节点x的重儿子
    }
    r[x] = pos;//记录当前节点所能到达的最大DFS序
}

void DFS2(int x,int fa,bool keep)//keep含义为此次DFS是否要保留(该函数用先到底理解)
{
    for (int i = head[x];i;i = e[i].next)//计算轻儿子的答案
    {
        if(e[i].to == fa||e[i].to == son[x]) continue;
        DFS2(e[i].to,x,false);
    }
    if(son[x])//计算重儿子的答案并保留数据(用于继承)
    {
        DFS2(son[x],x,true);//keep改为true
    }
    for (int i = head[x];i;i = e[i].next)//再次计算轻儿子
    {
        if(e[i].to == fa||e[i].to == son[x]) continue;
        for (int j = l[e[i].to];j<=r[e[i].to];j++)//子树节点的DFS序构成连续区间,直接遍历(省了很多递归函数的编写及简化理解)
        {
            addcolor(Node[j]);//添加颜色贡献
        }

    }
    addcolor(x);//加上自己
    ans[x] = getans();//获取答案,记录
    if(!keep)//如果不保留
    {
        for (int i = l[x];i<=r[x];i++)//删掉整棵以x为节点的树的贡献(因为keep == false,说明此节点是某节点的轻儿子的第一次遍历,可删)
        {
            delcolor(Node[i]);//删除贡献
        }
    }
}

int main()
{
    int n = read();//读入节点个数
    for (int i = 1;i<=n-1;i++)//建树
    {
        int a = read();
        int b = read();
        add(a,b);
        add(b,a);
    }
    for (int i = 1;i<=n;i++) color[i] = read();//读入每个节点颜色
    DFS1(1,0);//预处理树
    DFS2(1,0,false);//计算答案!!!核心函数(难理解)
    int q = read();//读入询问数
    for (int i = 1;i<=q;i++)//依次处理每次询问
    {
        int ask = read();
        printf("%d\n",ans[ask]);//o(1)输出答案
    }
    return 0;
}
```

### 点分治

```cpp
#define MAXN 100010
#define INF 10000001
int n,m;
int ask[1005]; // 记录询问
vector<pair<int,int>> e[MAXN]; // 边数组
int big[MAXN],maxn[MAXN],sum,rt; // 重心相关
bool judge[INF],ans[INF],vis[MAXN]; // 分治及记录相关
int dis[MAXN]; // 到根节点的距离
int rem[MAXN]; // 记录产生的距离
int que[MAXN]; // 记录此次计算过后要清空的距离

void getrt(int x,int fa) // 获取树的重心
{
    big[x] = 1;
    maxn[x] = 0; // 初始化
    for (auto v : e[x])
    {
        int to = v.first;
        if (to == fa || vis[to]) continue; // 注意vis
        getrt(to,x);
        big[x] += big[to];
        maxn[x] = max(big[to],maxn[x]);
    }
    maxn[x] = max(maxn[x],sum - big[x]);
    if (maxn[x] < maxn[rt]) rt = x;
}

void getdis(int x,int fa) // 获取到根节点的距离
{
    rem[++rem[0]] = dis[x]; // 记录记录
    for (auto v : e[x])
    {
        int to = v.first;
        int w = v.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[x] + w;
        getdis(to,x);
    }
}

void calc(int x) // 计算路径的核心函数
{
    int p = 0; // 初始化
    for (auto v : e[x])
    {
        int to = v.first;
        int w = v.second;
        if (vis[to]) continue;
        rem[0] = 0; // rem[0]用于记录当前节点的子树产生了多少个距离
        dis[to] = w;
        getdis(to,x);// 处理每个子树到当前节点(当前为根)的dis

        for (int i = 1; i <= rem[0]; i++) // 遍历当前节点为根产生的距离
        {
            for (int j = 1; j <= m; j++) // 遍历问题
            {
                if (ask[j] >= rem[i]) ans[j] |= judge[ask[j]-rem[i]]; // dp
            }
        }

        // 标记当前的距离
        for (int i = 1; i <= rem[0]; i++)
        {
            judge[rem[i]] = true;
            que[++p] = rem[i];
        }
    }
    // 处理完这个子树就清空judge
    for (int i = 1; i <= p; i++) judge[que[i]] = false;
}

void Solve(int x)
{
    vis[x] = judge[0] = true; // 到当前节点为0就是自己，且标记自己已经被当作子树处理过了
    calc(x); // 处理以x为根的子树
    for (auto v : e[x])
    {
        int to = v.first;
        if (vis[to]) continue;
        rt = 0; // 重新定义根
        maxn[rt] = INF;
        sum = big[to]; // 定义子树的大小
        getrt(to,0); // 找到子树的重心
        Solve(rt);
    }
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int x,y,w;
    cin >> n >> m;
    for (int i = 1; i <= n-1; i++)
    {
        cin >> x >> y >> w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    for (int i = 1; i <= m; i++) cin >> ask[i];
    maxn[rt] = sum = n; // 第一次先找一整棵树的重心，保证计算的时间复杂度
    getrt(1,0);
    Solve(rt);
    for (int i = 1; i <= m; i++)
    {
        if (ans[i]) cout << "AYE" << "\n";
        else cout << "NAY" << "\n";
    }
    return 0;
}
```

### 生成树

#### 最小生成树

##### Kruskal算法

```cpp
//特定的数据结构维护:并查集
//时间复杂度:o(mlogm+(a)n),主要来自于排序及并查集查询,m为边数,n为点数
typedef struct edge//直接存边
{
    int b,e,v;
}EDGE;
EDGE e[200001];
int f[200001];//并查集数组

int Find(int x)//并查集查找
{
    if (x == f[x]) return x;
    else return f[x] = Find(f[x]);
}

bool cmp(EDGE x,EDGE y)//边结构体按边权排序
{
    return x.v < y.v;
}

int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i;//初始化并查集
    for (int i = 1; i <= m; i++) cin >> e[i].b >> e[i].e >> e[i].v;
    sort(e+1,e+m+1,cmp);//排序
    int ans = 0;//初始化答案
    int finish = 0;//初始化完成的边数
    for (int i = 1;i<=m;i++)//枚举边
    {
        if (finish == n-1) break;//已经建好树了,退出
        int f1 = Find(e[i].b);//查找祖先
        int f2 = Find(e[i].e);//查找祖先
        if (f1 == f2) continue;//如果成环,之前有更小的边,跳过
        finish++;//边数加1
        ans += e[i].v;//答案累加
        f[f1] = f2;//连通区域合并合并
    }
    if (finish == n-1) cout << ans << "\n";//如果有MST,输出最小权值和
    else cout << "orz" << "\n";//否则输出无
    return 0;
}
```

##### Prim算法(堆优化)

```cpp
//时间复杂度:o(nlogm + m)
typedef struct edge//链式前向星存边
{
    int to,next,value;
}EDGE;
//边相关数组
EDGE e[200001<<1];
int head[5001];
int cnt;
//Prim相关数组
int dis[5001];//记录每个节点到已生成连通块的最小距离
int ans,finish;//记录答案及已加入的点的个数
bool vis[5001];//标记点是否已经在当前连通块中
//初始化变量,节点及边数量
int n,m;
//堆自定义相关
struct S
{
    int number,d;//记录当前点编号及到连通块的距离
};
bool operator<(const S&x,const S&y)//按到连通块的距离排序
{
    return x.d>y.d;
}
priority_queue<S> heap;//自定义堆

void add(int x,int y,int v)//加边
{
    e[++cnt].to = y;
    e[cnt].next = head[x];
    e[cnt].value = v;
    head[x] = cnt;
}
void Prim()//核心Prim
{
    memset(dis,127,sizeof(dis));//初始化dis为无穷大
    S temp = {1,0};
    heap.push(temp);//以1为起点开始Prim
    while (!heap.empty())//如果不空
    {
        if (finish >= n) break;//已经完成n个节点的连接,退出循环
        int u = heap.top().number;//获取堆顶的节点编号
        int d = heap.top().d;//获取最近距离
        heap.pop();//弹出
        if(vis[u]) continue;//如果已经连接,跳过
        vis[u] = true;//标记
        ans += d;//累加答案
        finish++;//已连接节点数加1
        for (int i = head[u]; i; i = e[i].next)//以当前节点去更新其他节点到当前连通块的距离
        {
            if (vis[e[i].to]) continue;//如果已经在连通块,跳过
            if (dis[e[i].to] > e[i].value)//如果更优(即比之前到连通块更近)
            {
                S save = {e[i].to,e[i].value};//存储相关数据
                heap.push(save);//入堆
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int x,y,v;
    cin >> n >> m;//输入节点个数及边的个数
    for (int i = 1; i<=m; i++)//建图
    {
        cin >> x >> y >> v;
        add(x,y,v);
        add(y,x,v);
    }
    Prim();
    if(finish == n) cout << ans << "\n";//有生成树,输出答案
    else cout << "orz" << "\n";//否则没有
    return 0;
}
```

##### 最小生成树唯一性判断(基于Kruskal算法)

```cpp
//背景:看似简单的思路,实际上细节多!!!代码坑多
//时间复杂度:o(mlogm + 2*m*a(n))
#include <bits/stdc++.h>
using namespace std;
typedef struct edge//Kruskal边结构体
{
    int a,b,value;
}EDGE;
EDGE e[100005];//边集
int f[1005];//并查集数组
bool cmp(EDGE x,EDGE y)//自定义比较
{
    return x.value<y.value;
}
int Find(int x)//并查集查找
{
    if(x == f[x]) return x;
    else return f[x] = Find(f[x]);
}
void Solve()//解决问题函数
{
    int n,m;
    cin>>n>>m;//输入节点数及边数
    for (int i = 1; i<=n; i++) f[i] = i;//初始化并查集
    for (int i = 1; i<=m; i++) cin >> e[i].a >> e[i].b >> e[i].value;//输入边数据
    sort(e+1,e+m+1,cmp);//排序
    //保险:让溢出的部分已知
    e[m+1].value = 0;
    e[m+1].a = 0;
    e[m+1].b = 0;
    //核心变量
    int finish = 0;//完成的边(因为题目求MST是否唯一,默认了有,所有该变量在我有保险的条件下无用,或者是说题目专门卡了e[m+1]这一点,可以i>m,break)
    int ans = 0;//最小权值和
    int sum1 = 0;//每个阶段相同的可放的边条数
    int sum2 = 0;//每个阶段实际放的条数
    int tail = 0;//尾指针,用于确定阶段的
    bool flag = false;//判断是否唯一
    for (int i = 1; i<=m+1; i++)//注意这里要是m+1,否则可能最后一次无法判断
    {
        if(i>tail)//该更换阶段了
        {
            if(sum1 != sum2)//如果实际用的与可用的数量不同
            {
                flag = true;//标记不唯一
                break;//退出循环
            }
            sum1 = 0;//重置阶段计数
            sum2 = 0;
            for (int j = i; j<=m+1; j++)//m+1还是要开保险安全
            {
                if (e[j].value != e[i].value)
                {
                    tail = j-1;//更新尾指针
                    break;//退出
                }
                if (Find(e[j].a) != Find(e[j].b)) sum1++;//如果可加,可加边数加1
            }
        }
        //注意这里不能else，因为更换阶段时的那一点也要用于判断的
        if(finish == n-1) continue;//有保险的情况下可有可无,无的话也可以无,加上i>m break  !!!注意不能break,否则判断不全
        int x = Find(e[i].a);
        int y = Find(e[i].b);
        if (x == y) continue;//判断是否可以连接
        f[x] = y;//合并
        finish++;//边加1
        sum2++;//实际阶段边数加1
        ans += e[i].value;//答案累加
    }
    if(flag) cout << "Not Unique!" << "\n";//不唯一输出
    else cout << ans << "\n";//输出答案
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int t;
    cin >> t;//输入测试组数
    while(t--)
    {
        Solve();
    }
    return 0;
}
```

## 最短路

### 一，全源最短路

#### floyd算法

```cpp
for (k = 1; k <= n; k++) 
{
    for (x = 1; x <= n; x++) 
    {
        for (y = 1; y <= n; y++) 
        {
            f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
        }
    }
}
```

### 二，单源最短路

#### Dijkstra算法

```cpp
//适用条件:仅适用于正边权
//数据结构:单调队列
//时间复杂度:o(mlogm)
typedef struct edge//链式前向星存边
{
    int to;
    long long value;
}EDGE;
typedef struct node//单调队列数据类型
{
    int u;//编号
    long long dis;//当前的最短路
}NODE;
struct cmp//自定义优先队列排序,维护小根堆
{
    bool operator()(NODE x,NODE y)
    {
        return x.dis > y.dis;
    }
};
vector<EDGE> e[100001];//邻接表存图
long long dis[100001];//最短路
bool vis[100001];//标记数组
priority_queue<NODE,vector<NODE>,cmp> heap;//优先队列
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,s,x,y;
    long long v;
    cin >> n >> m >> s;
    memset(dis,0x3f,sizeof(dis));//初始化为无穷
    dis[s] = 0;//初始化为0
    for (int i = 1;i<=m;i++)//建图
    {
        cin >> x >> y >> v;
        e[x].push_back({y,v});
    }
    heap.push({s,dis[s]});//起点入队
    while(!heap.empty())//Dijkstra算法
    {
        x = heap.top().u;//获取堆顶,即目前未算出最短路的集合中的最小值对应的点
        heap.pop();//弹出
        if(vis[x] == true) continue;//如果之前已经加入了最短路集合中,跳过它(因为不可能更优)
        vis[x] = true;//标记
        for (auto t:e[x])//松弛与该点有关的边
        {
            if(dis[t.to] > dis[x] + t.value)//如果更优
            {
                dis[t.to] = dis[x] + t.value;//更新
                heap.push({t.to,dis[t.to]});//入队
            }
        }
    }
    for (int i = 1;i<=n;i++) cout << dis[i] << " ";//输出
    return 0;
}
```

#### SPFA(可判断负环)

```cpp
typedef struct edge//链式前向星结构
{
    int to,value;
}EDGE;
vector<EDGE> e[500001];//邻接表存图
int cnt[10001];//用于判断负环的
int dis[10001];//单源最短路数组
bool vis[10001];//入队数组,防止重复入队
const int INF = 0x3f3f3f3f;//无穷大
const int no = ((long long)(1)<<31) - 1;//无解值
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,s,x,y,v;
    cin >> n >> m >> s;
    memset(dis,0x3f,sizeof(dis));//初始化
    dis[s] = 0;//初始化
    for (int i = 1; i<=m; i++)//建图
    {
        cin >> x >> y >> v;
        e[x].push_back({y,v});
    }
    vis[s] = true;//标记入队了
    queue<int> que;
    que.push(s);
    while (!que.empty())//SPFA算法
    {
        int now = que.front();
        que.pop();
        vis[now] = false;//出队后取消标记
        for (auto d:e[now])//遍历边
        {
            x = d.to,
            y = d.value;
            if(dis[x] > dis[now] + y)//更新最短路
            {
                dis[x] = dis[now] + y;
                cnt[x] = cnt[now] + 1;
                if(cnt[x] >= n)//如果超过了n-1条边,说明有负环
                {
                    cout<<"Have negative cycle!"<<"\n";//输出
                    return 0;//结束程序
                }
                if(!vis[x])//如果之前没有入队
                {
                    que.push(x);//在这一次入
                    vis[x] = true;//标记
                }
            }
        }
    }
    for (int i = 1; i<=n; i++)//输出
    {
        if(dis[i] == INF) cout << no << " ";
        else cout << dis[i] << " ";
    }
    return 0;
}
```

## 拓扑排序

### 一，Kahn算法(模板)

```cpp
queue<int> que;//初始化队列
for (int i = 1;i<=n;i++)//遍历顶点
{
    if(in[i] == 0) que.push(i);//入度为0的入队
}
vector <int> ans;//拓扑排序结果序列
while(!que.empty())
{
    int v = que.front();
    que.pop();
    ans.push_back(v);
    for (int i = head[v]; i; i = e[i].next)
    {
        in[e[i].to]--;
        if (in[e[i].to] == 0) que.push(e[i].to);
    }
}
```

### 二，拓扑排序唯一性判断

```cpp
queue<pair<char,int>> que;//集合中记录每个字母及其入度为0时的层数
vector<char> ans;//存储答案
int check = 0;//记录最大层数的
for (auto v : s)//找入度为0的点
{
    if (intemp[v] == 0) que.push({v,1});//入队且层数为1
}
while (!que.empty())//kahn算法,BFS
{
    char ch = que.front().first;//取字母
    int t = que.front().second;//取层数
    que.pop();//弹出!!!!
    ans.push_back(ch);//记录答案
    for (int i = head[ch]; i; i = e[i].next)//遍历它的边
    {
        intemp[e[i].to]--;//入度减1
        if(intemp[e[i].to] == 0)//当入度为0
        {
            que.push({e[i].to,t+1});//由当前层数加1
            check = max(check,t+1);//更新最大层数
        }
    }
}
//有稳定拓扑排序说明拓扑排序的层数是n,即最后判断无环的情况下层数是否为n
```

## 环问题

### 最小环(Floyd算法)

```cpp
for (int k = 1; k<=n; k++)
{
    for (int i = 1; i<=n; i++)
    {
        for (int j = 1; j<=n; j++)
        {
            //在更新最短路之前求最小环
            if(i != k&&j != k&&i != j) ans = min(ans,f[i][j] + e[i][k] + e[j][k]);//如果三个点不相等才能是环
            f[i][j] = min(f[i][j],f[i][k] + f[k][j]);//可以更新了,因为这一次k已经用过了(i,j),不可能再用了
            }
    }
}
```

### 连通性问题

#### 一，强连通分量(有向图Tarjan缩点)

```cpp
vector<int> e1[MAXN]; // 原图
vector<int> e2[MAXN]; // 缩点后的图
int a[MAXN],b[MAXN];

// Tarjan相关变量
int dfn[MAXN],low[MAXN],dfncnt;
int scc[MAXN],sc;
bool vis[MAXN];
stack<int> s;

int in[MAXN];

void Tarjan(int x)
{
    dfn[x] = low[x] = ++dfncnt;
    vis[x] = true;
    s.push(x);
    for (auto to : e1[x])
    {
        if (!dfn[to])
        {
            Tarjan(to);
            low[x] = min(low[x],low[to]);
        }
        else if (vis[to]) low[x] = min(low[x],dfn[to]);
    }
    if (low[x] == dfn[x])
    {
        sc++;
        while (true)
        {
            int temp = s.top();
            s.pop();
            vis[temp] = false;
            scc[temp] = sc;
            b[sc] += a[temp];
            if (temp == x) break;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e1[x].push_back(y);
    }
    for (int i = 1; i <= n; i++)
    {
        if (!scc[i]) Tarjan(i);
    }
    for (int i = 1; i <= n; i++) // 建立新图
    {
        for (auto to:e1[i])
        {
            if (scc[to] == scc[i]) continue;
            e2[scc[i]].push_back(scc[to]);
            in[scc[to]]++;
        }
    }
    return 0;
}
```

#### 二，割点

```cpp
vector<int> e[20005];
int dfn[20005],low[20005],dfncnt;
bool flag[20005];
int res;
void Tarjan(int x,int fa)
{
    dfn[x] = low[x] = ++dfncnt;
    int child = 0; // 用于处理起点的
    for (auto to : e[x])
    {
        if (to == fa) continue;
        if (!dfn[to])
        {
            child++;
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[x] == false&&x != fa&&low[to] >= dfn[x])
            {
                res++;
                flag[x] = true;
            }
        }
        else low[x] = min(low[x],dfn[to]);
    }
    if (x == fa&&child >= 2&&flag[x] == false) // 特判起点的
    {
        res++;
        flag[x] = true;
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    for (int i = 1; i <= n; i++)
    {
        if (!dfn[i]) Tarjan(i,i);
    }
    cout << res << "\n";
    for (int i = 1; i <= n; i++)
    {
        if (flag[i]) cout << i << " ";
    }
    return 0;
}
```

#### 三，割边(桥)

```cpp
void Tarjan(int x,int fa)
{
    dfn[x] = low[x] = ++dfncnt;
    for (auto v : e1[x])
    {
        int pos = v.first; // 获取编号
        int to = v.second;
        if (to == fa) continue;
        if (!dfn[to])
        {
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[pos] == false && low[to] > dfn[x]) flag[pos] = true;
        }
        else low[x] = min(low[x],dfn[to]);
    }
}
```

#### 四，双连通分量(无向图Tarjan缩点)

```cpp
//解释为什么要编号求桥：如1->2为桥，以前仅标记了1->2，虽然缩点的时候1->2无法到，但是2->1却可以，故产生错误
vector<pair<int,int>> e1[MAXN]; // 要以编号的形式记录边，否则会得到错误的缩点
vector<int> e2[MAXN]; // 缩点后的新图
int dfn[MAXN],low[MAXN],dfncnt;
bool flag[MAXN]; // 判断边编号是否未桥
int scc[MAXN],sc; // 缩点数组，有点像强连通分量

void Tarjan(int x,int fa) // Tarjan找桥
{
    dfn[x] = low[x] = ++dfncnt;
    for (auto v : e1[x])
    {
        int pos = v.first;
        int to = v.second;
        if (to == fa) continue;
        if (!dfn[to])
        {
            Tarjan(to,x);
            low[x] = min(low[x],low[to]);
            if (flag[pos] == false && low[to] > dfn[x]) flag[pos] = true; // 判断依据，标记边的编号
        }
        else low[x] = min(low[x],dfn[to]);
    }
}
void DFS(int x,int fa) // 边双缩点
{
    scc[x] = sc; // 记录缩点后的节点编号
    for (auto v : e1[x])
    {
        int pos = v.first;
        int to = v.second;
        if (to == fa) continue;
        if (flag[pos] || scc[to]) continue; // 如果是桥或者已经在连通块中
        DFS(to,x);
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e1[x].push_back({i,y});
        e1[y].push_back({i,x});
    }
    for (int i = 1; i <= n; i++) // 无向图求割边
    {
        if (!dfn[i]) Tarjan(i,i);
    }
    for (int i = 1; i <= n; i++) // 双连通分量边缩点
    {
        if (!scc[i]) // 如果没有所属的缩点
        {
            sc++;//点数+1
            DFS(i,0);
        }
    }
    for (int i = 1; i <= n; i++) // 建立新的无向图
    {
        for (auto v : e1[i])
        {
            int to = v.second;
            if (scc[i] == scc[to]) continue;
            e2[scc[i]].push_back(scc[to]);
            // 注意只能加一次，由于双向的缘故，另一边也会通过遍历加到
            // 如果下面代码激活了，那么会超时
            //e2[scc[to]].push_back(scc[i]);
        }
    }
    return 0;
}
```

#### 欧拉图

##### 有向图的欧拉路径(欧拉回路)

```cpp
//必要条件：变成无向图后图连通，本题保证了，故不用判断
#include <bits/stdc++.h>
#define MAXN 200005
using namespace std;
vector<int> e[MAXN];
int pos[MAXN]; // 记录遍历到当前节点的哪条出边了
stack<int> ans;
int in[MAXN],out[MAXN]; // 记录入度与出度
void DFS(int x) // 核心DFS
{
    for (int i = pos[x]; i < e[x].size(); i = pos[x]) // 注意这里不能i++，只能i = pos[x],因为pos[x]可能会在递归过程中变化
    {
        pos[x]++;
        DFS(e[x][i]);
    }
    ans.push(x); // 最后才入栈
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m,x,y;
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        e[x].push_back(y);
        in[y]++;
        out[x]++;
    }
    for (int i = 1; i <= n; i++) sort(e[i].begin(),e[i].end()); // 题目要求输出路径字典序，故排序

    int s = 1; // 记录起点，初始化为1，因为如果存在欧拉回路，每个点都可以是起点，字典序最小出发
    bool flag = true; // 判断存在欧拉回路
    bool have[2] = {0,0}; // 判断欧拉路径的起点与终点，用于判断欧拉路径
    for (int i = 1; i <= n; i++)
    {
        if (in[i] == out[i]) continue; // 欧拉回路判断条件
        flag = false; // 不存在欧拉回路

        if (out[i] - in[i] == 1) // 出度比入度大1，为起点
        {
            s = i;
            have[0] = true;
        }
        else if (in[i] - out[i] == 1) // 终点
        {
            have[1] = true;
        }
        else // 不存在欧拉路径
        {
            cout << "No" << "\n";
            return 0;
        }
    }
    if (!flag && (have[0] == false || have[1] == false)) // 如果即无欧拉回路也无欧拉路径
    {
        cout << "No" << "\n";
        return 0;
    }
    DFS(s);
    while (!ans.empty()) // 倒序输出即为答案
    {
        cout << ans.top() << " ";
        ans.pop();
    }
    return 0;
}
```

##### 无向图的欧拉路径(欧拉回路)

```cpp
//背景：暑假学习，无向图的欧拉路径模板
#define MAXN 505
int e[MAXN][MAXN]; // 邻接矩阵存图，便于字典序输出
int pos[MAXN]; // 用于非邻接矩阵存图的字典序输出（本模板中无用）
int cnt[MAXN]; // 记录每个点的度数
int oddp[MAXN]; // 记录奇数度数的点
int tot; // 记录奇数度数的点的数量
stack<int> ans; // 记录答案

void DFS(int x) // 核心DFS
{
    for (int i = 1; i <= 500; i++)
    {
        if (e[x][i]) // 有边没走
        {
            e[x][i]--; // 双向都要减
            e[i][x]--;
            DFS(i);
        }
    }
    ans.push(x); // 记录
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int m,s = 99999999,x,y;
    cin >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> x >> y;
        s = min(s,x); // 找最小起点
        s = min(s,y);
        e[x][y]++;
        e[y][x]++;
        cnt[x]++; // 累加度数
        cnt[y]++;
    }
    for (int i = 1; i <= 500; i++)
    {
        if (cnt[i]%2) // 奇数入度
        {
            oddp[++tot] = i;
        }
    }
    if (tot != 2 && tot) // 如果存在奇数入度的点，且不为2个，则无欧拉路径
    {
        //虽然题目保证了有，但是作为模板还是很有必要的
        cout << "No solution!" << "\n";
    }
    int b;
    if (tot) // 存在奇数度数，则要找起点
    {
        b = min(oddp[1],oddp[2]);
    }
    else // 否则存在欧拉回路，随便
    {
        b = s; // 取字典序最小的
    }
    DFS(b);
    while (!ans.empty())
    {
        cout << ans.top() << "\n";
        ans.pop();
    }
    return 0;
}
```
