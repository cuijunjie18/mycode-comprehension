//背景:时隔多日再做状压dp已经无法理解,故隔了一天才做出
//原理:状态压缩加子集枚举
//时间复杂度:o(3^n)
#include <bits/stdc++.h>
using namespace std;
int w[17],t[17];//记录每个人的重量及过桥时间
int g[17];//记录每个人对应的二进制状态,美化代码
int dp[1<<16],W[1<<16],T[1<<16];//记录对应状态的答案最小值,体重和,时间最大值
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int m,n;
    cin>>m>>n;
    for (int i = 1;i<=n;i++) g[i] = (1<<(i-1));//记录对应编号的二进制状态
    for (int i = 1;i<=n;i++) cin>>t[i]>>w[i];//输入时间与体重
    for (int i = 1;i<=(1<<n)-1;i++)//枚举状态,记录数据
    {
        for (int j = 1;j<=n;j++)//枚举该状态下的人
        {
            if((i&g[j]) == 0) continue;//如果不在,跳过
            T[i] = max(T[i],t[j]);//否则取时间最大值
            W[i] = W[i^g[j]] + w[j];//体重求和
        }
    }
    memset(dp,127,sizeof(dp));//求最小值,初始化为正无穷
    dp[0] = 0;//难理解,dp的边界处理,没有人过桥时间最小值当然是0
    for (int i = 1;i<=(1<<n)-1;i++)//枚举状态
    {
        for (int j = i;;j = (j-1)&i)//枚举子集进行状态切割(子集认为是已经满足条件的了,或者说已经分好最优的组了,目的是让切割出来的为一组试试)
        {
            if(W[i^j] <= m) dp[i] = min(dp[i],dp[j]+T[i^j]);//如果切割出的状态体重和不超,利用切割出的状态进行dp
            if(j == 0) break;//这里放在上一行代码后目的是处理单个人的状态
        }
    }
    cout<<dp[(1<<n)-1]<<"\n";//输出答案
    return 0;
}
