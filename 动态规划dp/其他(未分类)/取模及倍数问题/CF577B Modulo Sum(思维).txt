//原理:抽屉原理(鸽巢原理) + 01背包
//原题数据范围:1<=n<=10e6,2<=m<=1000;
/*抽屉原理在本题的应用:前缀和有n个,而模数最多m个,当n>m时,必有前缀和相等(抽屉原理),故必有前缀和之差(构成了一个连续序列,也是一个合法的数组)为0,即被m整除,从而
  实现了n>=1000范围时的o(1)回答,当n<=1000时,便可以01背包*/
#include <bits/stdc++.h>
using namespace std;
unordered_map<int,int>s;
int f[1001][1001];//dp数组,处理到第i个数,余数是j的组合存不存在,在为1,不在为0
int a[1000001];//数字数字
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int n,m;
    cin>>n>>m;//输入序列长度及模数
    for (int i = 1;i<=n;i++)//依次输入数据
    {
        cin>>a[i];
        a[i] %= m;//因为求模数,过程取模
    }
    if(n>m)//o(1)判断
    {
        cout<<"YES"<<"\n";
        return 0;
    }
    for (int i = 1;i<=n;i++)//01背包
    {
        f[i][a[i]] = 1;//!!!细节,每个新数都能满足自己的模数
        for (int j = 0;j<=m-1;j++)//顺序逆序无关
        {
            f[i][j]  |= f[i-1][j];//细节,一定要继承前面(没选当前数)
            f[i][j] |= f[i-1][(j+m-a[i])%m];//选了当前数的情况
            //我的错误:只写了f[i][(j+a[i])%m] |= f[i-1][j]; 这种dp转移实际上是忽略了第一个转移方程,利用刷表法,等于默认了当前数一定被选
        }
    }
    if(f[n][0]) cout<<"YES"<<"\n";//输出
    else cout<<"NO"<<"\n";
    return 0;
}
