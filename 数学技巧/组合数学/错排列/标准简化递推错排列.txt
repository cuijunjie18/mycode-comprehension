/*原理:1 . 分步计数原理 : 使用 分步计数原理 , 先统计 第一封信的排列方法 , 然后再讨论 其余信的排列方法数 ;

( 1 ) 第一步 : 首先找出一封信 a aa 出来 , 这封信不能排在其本身位置 , 只能放在其余 n − 1 n-1n−1 个位置上 , 因此有 n − 1 n-1n−1 种排法 ;

( 2 ) 第二步 : 现在讨论其余除 a aa 之外的其余信的位置的错排问题 ;



2 . 分类计数原理

假设第一封信 a aa 占据了 b bb 的位置 , 那么此时 b bb 放在哪个信封分两种情况 , b bb 放在 a aa 位置 , 或 b bb 不放在 a aa 位置 ;


( 1 ) 第一类 : 第一种情况是放在 a aa 位置 , 此时 b bb 放在 a aa 位置 , 剩下 n − 2 n-2n−2 封信进行错排 , 方案数是 D ( n − 2 ) D(n-2)D(n−2)

( 2 ) 第二类 : 第二种情况是 b bb 没有去 a aa 的位置 , 那么 b bb 可能出现在除 a aa 之外的任何位置 , b bb 有 n − 2 n-2n−2 个位置可以去 , 不能去 a , b a,ba,b 位置 , 其余所有元素都有 n − 2 n-2n−2 个位置可以去 ( a , b a,ba,b 位置不能去 ) , 这种情况下 相当于除 a aa 之外的其它元素的错排问题 , 即 n − 1 n-1n−1 个元素的错排问题 , 方案数是 D ( n − 1 ) D(n-1)D(n−1) ; ★ ( 核心推导逻辑 ) ★

( 3 ) 加法法则 : 汇总上述分类计数原理 , 使用 加法法则 , 计算结果是 D ( n − 1 ) + D ( n − 2 ) D(n -1) + D(n-2)D(n−1)+D(n−2)
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-NC-SA 版权协议，转载请附上原文出处链接和本声明。
                        
原文链接：https://blog.csdn.net/shulianghan/article/details/109438773 */
#include <bits/stdc++.h>
using namespace std;
int d[10];
int main()
{
	//舍弃了D(0),对D(1) 与 D(2)赋初值 
    d[1] = 0;
    d[2] = 1;
    for (int i = 3;i<=10;i++)
    {
        d[i] = (i-1)*(d[i-2] + d[i-1]);
    }
    for (int i = 0;i<=10;i++) cout<<d[i]<<endl;
    return 0;
}
