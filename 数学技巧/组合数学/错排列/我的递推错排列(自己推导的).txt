//背景:我自己回忆高中知识,利用正难则反的思想去推导的
//原理解释及证明:
/*已知d[0] = d[1] = 0,d[2] = 1,想错排序关系如果不考虑情况,排序有A3(全排列数)种,减去不是错排列的情况,剩下的即是错排列
基于此发现,举例子:D(3) = A3 - 1个人站队位置的所有情况 - 2个人站队位置的所有情况(2个人对了,3个人肯定对,不需要考虑3个人)
故推广至D(n) = An - c[n][1]*D(n-1) - c[n][2]*D(n-2) - ...... - c[n][n-1]*D(1),而由于D(1)为0,导致最后一种情况未
减去,可以特殊处理减1或令D(1) = 1(虽然是错的,但可以保证计算正确),证毕*/
#include <bits/stdc++.h>
using namespace std;
long long d[10];//用于存错排列数
long long a[10];//用于存全排列数
long long c[20][20];//用于存组合数
int main()
{
    a[1] = 1;//初始化全排列数a[1] = 1
    for (int i = 2;i<=10;i++) a[i] = a[i-1]*i;//计算全排列数
    d[0] = 0;//初始化错排列数
    d[1] = 0;
    for (int i = 0;i<=10;i++)//初始化组合数!!!一定要从0开始
    {
        c[i][0] = 1;
        c[i][i] = 1;
    }
    for (int i = 1;i<=10;i++)//计算组合数
    {
        for (int j = 1;j<=i-1;j++)//其实j也可以到i
        {
            c[i][j] = c[i-1][j] + c[i-1][j-1];
        }
    }
    for (int i = 2;i<=10;i++)//计算错排列
    {
        d[i] = a[i];//按公式计算
        for (int j = 1;j<=i-1;j++)//枚举1到n-1(此处n为i)
        {
            d[i] -= c[i][j]*d[i-j];
        }
        d[i] -= 1;//单独减1
    }
    for (int i = 0;i<=10;i++) cout<<"D("<<i<<") = "<<d[i]<<endl;
    return 0;
}
