//背景:无法理解的博弈论状压dp转移     补充:现在理解了(目前仅对于这道题)
//思路关键:已经知道当全部字符串被选(假设可以做到),即满状态,该状态不可能有后继状态,则其必输
//原理:博弈论 + 状压dp(以更晚状态推出更早状态的dp)
//时间复杂度:o(2^n * n^2)
#include <bits/stdc++.h>
using namespace std;
int f[1<<16][17];//状压数组,表示某个字符串使用状态下最后使用的是i的状态的必胜情况,1为必胜,2为必败
int g[17];//美化数组,代表某个数的二进制状态
int k[17][17];//表示i是否可以后接上j,1为可以,2为不行
string s[17];//字符串数组
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//加快输入输出
    int n;
    cin>>n;//输入字符串数量
    for (int i = 1;i<=n;i++) g[i] = (1<<(i-1));//美化数组预处理
    for (int i = 1;i<=n;i++) cin>>s[i];//输入字符串
    for (int i = 1;i<=n;i++)//判断连接情况
    {
        for (int j = 1;j<=n;j++)
        {
            if(i == j) continue;
            if(s[i][s[i].size()-1] == s[j][0]) k[i][j] = 1;//如果i的最后一个字符等于j的第一个字符,表示能接上
        }
    }
    for (int t = ((1<<n) - 1);t>=0;t--)//!!!注意为什么要倒着dp(因为只有满状态是已知的必败状态),自己想想如果用DFS其实不也是先到底部吗?
    {
        for (int i = 1;i<=n;i++)//枚举已经在状态的字符串
        {
            if((t&g[i]) == 0) continue;//如果不在状态,跳过
            bool flag = true;//对当前状态的初始胜负状态
            for (int j = 1;j<=n;j++)//枚举要接上的字符串
            {
                if(t&g[j]) continue;//不能包含在状态t中
                if(k[i][j] == 0) continue;//如果不能接上,跳过
                if(f[t|g[j]][j])//如果能接上了,且后继状态为必胜,则当前状态必败(因为对手一定会采取这个最优策略)
                {
                    flag = false;//标记必败
                    break;//退出循环
                }
            }
            //如果能达到当前状态必胜可能:1,当前状态无法接上其他字符串;2,当前状态所有能接上的状态均为必败状态
            f[t][i] = flag;//为当前状态赋予胜负状态
        }
    }
    for (int i = 1;i<=n;i++)//枚举从某个字符串开始的必胜情况
    {
        if(f[g[i]][i])//只要有一个必胜
        {
            cout<<"First"<<"\n";//输出必胜
            return 0;//结束
        }
    }
    cout<<"Second"<<"\n";//否则必败
    return 0;
}
