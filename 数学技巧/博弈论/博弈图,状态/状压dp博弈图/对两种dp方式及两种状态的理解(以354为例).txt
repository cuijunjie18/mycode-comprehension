1,对于两种dp数组内状态含义的理解:(1)二进制状态下1为剩余的,即未被选的,这时候要正着dp
                             (2)二进制状态下1为被选的,这是候要倒着dp
  核心:正着与倒着都是为了DFS中先到达底部计算的结果(即全部被选这个状态),即以更晚的状态去推更早的状态,所以是合理的
  总结:两种dp方式设置没有本质的区别,关键是对状态的理解
  
2,对于dp方式的理解(也是对状态的理解),即偏差产生的主要原因(为了方便,此次均以正着dp的设置为例):
  注意:(1)(2)均是对应自己的状态理解去解释的,且代码核心来自abc354E题

(1)dp内状态对应的表示是:当前状态后,操作的人的胜负状态(程哥的解释),这种情况下是要判断当前状态是否能够到达一个必败态,如果可以则当前必胜,否则必败,故要设置flag = false

   代码:
   for (int t = 0;t<=((1<<n)-1);t++)
    {
        bool flag = false;//初始化为必败
        for (int i = 1;i<=n;i++)
        {
            for (int j = i+1;j<=n;j++)
            {
                if((t&g[i])&&(t&g[j])&&k[i][j])
                {
                    if(dp[t - g[i] - g[j]] == 0)//如果能够到达一个必败态
                    {
                        flag = true;//当前必胜
                        break;
                    }
                }
            }
        }
        dp[t] = flag;
    }
    //即一开始全部没选的时候,后面是否必胜
    if(dp[(1<<n)-1]) cout<<"Takahashi"<<"\n";//注意这里是主要保证flag设置
    else cout<<"Aoki"<<"\n";


(2)通过操作,到达了当前状态,此时该人的胜负状态(我的解释),这种情况下如果有可以通过操作到达一个必胜态(本质是对手采取了最优策略),即当前状态必输,反之必胜,故要设置
flag = true

   代码:
   for (int t = 0;t<=((1<<n)-1);t++)
    {
        bool flag = true;//初始化为必胜
        for (int i = 1;i<=n;i++)
        {
            for (int j = i+1;j<=n;j++)
            {
                if((g[i]&t)&&(g[j]&t)&&k[i][j])
                {
                    if(dp[t - g[i] - g[j]])//如果下一个人通过操作到达了一个必胜态
                    {
                        flag = false;//操作到当前状态的人必败
                        break;
                    }
                }
            }
        }
        dp[t] = flag;
    }
    //即一开始全部没选,如果先手必胜,则说明了谁到达当前全部没选的状态都是必败,故要取反
    if(!dp[(1<<n)-1]) cout<<"Takahashi"<<"\n";//注意这里与上面的刚好相反
    else cout<<"Aoki"<<"\n";
    
总结:(1)确实是第一种dp状态理解更好,第二种,即我的一开始理解,确实边界较难理解
	(2)由组合可以发现总共有4种写法(本质两种)
                