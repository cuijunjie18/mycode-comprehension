//背景:我记得我比赛的时候做过，但是找不到原题了，发现洛谷这题差不多
/*原理:洛谷题解:先约定，左指针 i 初始值为 1,以及右指针 j。从左往右逐个元素进行枚举，
①、如果某个元素值与下标相同，代表该元素处于正确的位置，左指针 i 加 1，枚举下一个元素。
②、不同则代表该元素处于不正确的位置，此时左指针 i 指向的下标即为排序的左端点，因此生成右指针 j ，初始化为 i+1开始往后查找排序的右端点。该查找过程还需要一个 
maxv变量来维护双指针范围内的区间最大值，当右指针j不停向右滑动，直至指向的下标大于等于区间最大值时，右指针j指向的下标即为排序的右端点（这个道理应该是显然的，因为如果右指针 j 指向的下标不如区间最大值 maxv 大，代表还没找到区间最大值的对应位置，还需要进一步扩大区间长度，所以右指针 j 还需要继续右移）。此时排序区间长度为 
j - i + 1。更新左指针 i 为右指针 j 的下一个位置，重复以上过程，直至全部元素枚举完毕。*/
//时间复杂度:o(n)
#include <bits/stdc++.h>
using namespace std;
void Solve()
{
    int n;
    scanf("%d",&n);
    int number[n+1];
    for (int i = 1;i<=n;i++) scanf("%d",&number[i]);//输入每组数据的数字
    int i = 1,j = 1;//定义左右指针
    int ans = 0;//初始化答案
    while(i<=n)//指针在整个区间移动直到移动完
    {
        if(i == number[i])//如果位置正确，左指针直接加1
        {
            i++;
        }
        else//否则需要排序了
        {
            int m = number[i];//初始化左右指针区间的最大值
            j = i + 1;//右指针
            m = max(m,number[j]);//取最大值
            while(m>j)//如果最大值还大于右指针的下标，移动右指针直到相同，即可以排序
            {
                j++;//右指针继续移动
                m = max(m,number[j]);//继续取最大值
            }
            ans += (j - i + 1);//更新答案
            i = j + 1;//更新左指针
        }
    }
    printf("%d\n",ans);//输出答案
}
int main()
{
    int t;
    scanf("%d",&t);//输入t组测试数据
    while(t--)
    {
        Solve();
    }
    return 0;
}
