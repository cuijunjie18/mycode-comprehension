//背景:字符串的周期性问题,一开始不太理解,后来看了题解自己画图推导出来了
//本题题意:本题给出的是重复拼接字符串子串,求最小周期,也就是说假定了原字符串是周期函数,给分析证明提供了思路
//公式:ans = n - LPS[n-1]
#include <bits/stdc++.h>
using namespace std;
void Prefixion(int LPS[],string s)//前缀函数
{
    LPS[0] = 0;//不要忘了初始化
    for (int i = 1;s[i] != '\0';i++)
    {
        int j = LPS[i-1];
        while(j > 0&&s[j] != s[i]) j = LPS[j-1];
        if(s[j] == s[i]) j++;
        LPS[i] = j;
    }
}
void Solve()
{
    int n;
    string s;
    cin>>n;//输入子串长度
    cin>>s;//输入字符串
    int LPS[n];//定义前缀函数
    Prefixion(LPS,s);//求前缀函数
    cout<<n - LPS[n-1]<<"\n";//输出最小周期
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int t = 1;
    while(t--)
    {
        Solve();
    }
    return 0;
}

/*证明ans = n - LPS[n-1],思路:
(1)证明特殊情况,即先对完整周期字符串进行证明,这时候的字符串组成是 [1][2][3][4] ,即4个周期拼接,所以由前缀函数的定义,有

   [1][2][3] = [2][3][4],所以LPS[n-1] = 3*T,即三个周期,则ans = n(即4*T) - LPS[n-1] = 4*T - 3*T = T;
   
   对于完整周期子串显然成立.
   
(2)证明一般情况,即证明非完整周期字符串,假设给出的字符串是 [末部分][1][2][3][前部分] ,即中间有完整的周期,两边是不确定长度的,可能为0.

   (为了方便,此处取[末部分] = [e],[前部分] = [b])
   
   1,当len([e]) = len([b]) = 0时,即(1)的情况,显然成立.
   
   2,当len([e]) = 0,len([b]) != 0时此时字符串为 [1][2][3][b],由于[b]是周期的一部分,则[3]中包含[b],有
     [1][2][b] = [2][3][b],此时 LPS[n-1] = 2*T + len([b]), n = 3*T + len([b]),显然有
     ans = n - LPS[n-1] == 3*T + len([b]) - 2*T - len([b]) = T,成立.
     
   3,当len([b]) = 0,len([e]) != 0时同理.
   
   4,当len([e]) != 0,且len([b]) != 0时,此时字符串为 [e][1][2][3][b],根据2,3,有
     [e][1][2][b] = [e][2][3][b],符合前缀函数定义,此时LPS[n-1] = 2*T + len([b+e]),n = 3*T + len([b+e])
     显然有ans = n - LPS[n-1] = T,得证
     
   5,当[e][b]内部没有完整的周期时,显然[e][b]可以自己组成最小周期,此时的LPS[n-1] = 0,ans = len([e+b]),为自己,得证