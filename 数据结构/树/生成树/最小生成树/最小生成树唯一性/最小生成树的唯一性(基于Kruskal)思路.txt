思路一:1.对图中的每一条边，扫描其他边，如果存在相同权值的边，则对此边做标记。
	  2.然后使用Kruskal（或者prim）算法求出最小生成树。
      3.如果这时候的最小生成树没有包含未被标记的边，即可判定最小生成树唯一。如果包含了标记的边，那么依次去掉这些边，再求最小生成树，如果求得的
        最小生成树的权值和原来的最小生成树的权值相同，即可判断最小生成树不唯一。
      时间复杂度:o(mlogm + m*n*a(n)),其中m为边数,n为节点数



思路二:考虑最小生成树的唯一性。
      如果一条边不在最小生成树的边集中,并且可以替换与其权值相同并且在最小生成树边集的另一条边。那么,这个最小生成树就是不唯一的。
      
	  对于Kruskal算法，只要计算为当前权值的边可以放几条，实际放了几条，如果这两个值不一样，那么就说明这几条边与之前的
	  边产生了一个环（这个环中至少有两条当前权值的边，否则根据并查集，这条边是不能放的），即最小生成树不唯一。

      寻找权值与当前边相同的边，我们只需要记录头尾指针，用单调队列即可在 O(a(m))（m 为边数）的时间复杂度里优秀解决这个问题（基本与原算法时间相同）。

