#include <bits/stdc++.h>
using namespace std;
int n,m,ans;
bool visit[100001];//标记数组
int f[100001];//每个点所能到达的最大点，用于记忆化，初始化为0
vector <int> g[100001];//邻接表存储有向图
void DFS(int x)//搜索
{
    if(g[x].size() == 0) return;//如果该点是终点了，返回
    for (int i = 0,k = g[x].size();i<k;i++)//枚举该点可以到达的位置
    {
        if(!visit[g[x][i]])//如果没有去过
        {
            visit[g[x][i]] = 1;//标记
            if(f[g[x][i]] != 0)//如果之前已经有过最大值，直接与当前ans比较，取较大值，记忆化搜索减枝
            {
                ans = max(f[g[x][i]],ans);
            }
            else//否则往下搜索
            {
                ans = max(ans,g[x][i]);//先去值再搜索，否则丢失数据
                DFS(g[x][i]);
            }
        }
    }
}
int main()
{
    int a,b;
    scanf("%d%d",&n,&m);//记录点的个数与边的个数
    for (int i = 1;i<=m;i++)//存图
    {
        scanf("%d%d",&a,&b);//意思是由a到b有路
        g[a].push_back(b);
    }
    for (int i = 1;i<=n;i++)//正着搜索
    {
        ans = i;//该点能到达的最大编号至少大于自己
        memset(visit,false,sizeof(visit));//标记清零
        visit[i] = true;//自己先标记
        DFS(i);//从自己开始搜索
        f[i] = ans;//记录这一次搜索得到的最大答案
        printf("%d ",ans);//输出
    }
    return 0;
}