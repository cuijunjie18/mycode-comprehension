1,Bellman-Ford算法是求单源最短路的算法,时间复杂度为o(nm),不太优秀

2,Bellman-Ford算法可以求有向图与无向图的单源最短路

3,Bellman-Ford算法可以处理图中存在负边权的情况

4,(OI-wiki)需要注意的是，以 S 点为源点跑 Bellman–Ford 算法时，如果没有给出存在负环的结果，只能说明从 S 点出发不能抵达一个负环，而不能说明图上不存在负环。
因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 0 的边，然后以超级源点为起点执行 Bellman–Ford 算法。

5,松弛最多n-1次的理解:
(知乎)其主要思想：对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。换句话说，第1轮在对所有的边进行松弛后，得到的是源点最多经过一条边到达其他顶点的最短距离；第2轮在对所有的边进行松弛后，得到的是源点最多经过两条边到达其他顶点的最短距离；第3轮在对所有的边进行松弛后，得到的是源点最多经过一条边到达其他顶点的最短距离......
(OI-wiki)在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少 +1，而最短路的边数最多为 n-1，因此整个算法最多执行 n-1 轮松弛操作。
(我的)每次松弛都会使能延伸的点多经过一点(哪怕没更新,即成功松弛),而当最多处理了n-1个点后,即是一种遍历了,故不会有更多次了