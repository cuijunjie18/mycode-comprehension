数组f[k][x][y]含义:x到y只经过 1到k的最小距离


//模板1:三维数组
for (k = 1; k <= n; k++)
{
  for (x = 1; x <= n; x++)
  {
    for (y = 1; y <= n; y++) 
    {
      f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);
    }
  }
}

//模板2:二维数组(滚动数组)
for (k = 1; k <= n; k++) 
{
  for (x = 1; x <= n; x++) 
  {
    for (y = 1; y <= n; y++) {
      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
    }
  }
}

下面给出我对滚动数组省略第一维k的证明:
如果省略了第一维,也就是要证明经过f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);后
               当前(x,y)对应的f[x][y]已经是f[k][x][y],而之后所有的f[a][b],1<=a<=n,1<=b<=n在当前k下的更新
               依旧是接受来自f[k-1]的更新(也就是滚动的核心:更新只能来自之前的),而不能来自当前更新过的了.
               
               而在假设中,f[x][y] 刚刚被更新了,所以它隐藏的第一维已经变为k了,接下来用反证法:
               如果滚动数组不成立,也就是说要有一个更新出现了问题:来自现在的k而不是k-1了.
               又f[x][y]是已经更新为k了,所以要再次出现(x,y)对,有两个情况:
               
               1,[x][k]中 k = y,而这时候转移为f[y][x][y] = min(f[k - 1][x][y], f[k - 1][x][y] + f[k - 1][y][y]);
                 上式等价于f[y][x][y] = min(f[k - 1][x][y], f[k - 1][x][y] + 0);即f[y][x][y] = f[k-1][x][y]；
                 其等价于该次转移无效
               2,[k][y]中 k = x,同上理可证得该情况的转移无效
               
               而当情况不满足上面的两种情况时,由于x与y在循环中是递增的,所以不会再次出现当前(x,y),故更新都来自之前的
               
               由上可知,所有的转移都是无效或者来自之前的,不存在来自现在的,故滚动数组成立,与假设的滚动数组不成立矛盾
               故可省略第一维.